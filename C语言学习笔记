                                       C语言学习笔记
                                  吕聪 2025年3月2日08:37:24

C语言发展史:
	1960   原型A语言->ALGOL语言
	1963   CPL语言
	1967   BCPL语言
	1970   B语言
	1973   C语言

C语言特点:
	1、基础性语言
	2、语法简洁，紧凑，方便，灵活
	3、运算符，数据结构丰富
	4、结构化，模块化编程思想
	5、移植性好，执行效率高
	6、允许直接对硬件操作(最重要的特性）

C语言学习建议:
	1、概念的正确性
	2、动手能力，能够耐得住寂寞，没有程序员是培训出来的
	3、阅读优秀的程序段
	4、大量练习、面试题

C语言课程讲解思路:
	1、基本概念
	2、数据类型，运算符和表达式是如何生成的
	3、输入输出专题
	4、流程控制
	5、数组
	6、指针
	7、函数
	8、构造类型
	9、动态内存管理
	10、调试工具和调试技巧(GDB,make) GDB主要是用来已经明确了错误的位置，然后进行调试的时候，效率很高 
	11、常用库函数
	
	
平台介绍:64位的redhat6,vim,gccc(make)

main函数的多种写法
	C语言一开始的时候就没有void类型，所以当时的编译器就认为main函数返回的是int类型，但是后来增加了void类型之后，就认为main函数是特殊的，因为main函数作为进程的入口、出口、程序是不需要返回值的，其中的argc、argv是命令行的参数，所以如果不需要命令行传入参数的话，就将参数写成void，具体怎么样要看代码的运行环境。
	void main(void)
	void main(int argc, char **argv) // 其中argv也可以写作 char *argv[]
	int main(int argc, char **argv);
	int main(void);



hello.c:
C源文件-预处理-编译-汇编-链接-可执行文件
gcc:比较常用的点在于可以直接打印出当前出错的行号
	gcc -E hello.c
	所有带有#的都是在预处理阶段处理掉的 比如说#include #define等等，因为shell命令是默认输出到终端的，但还需要进行下一步的编译操作，因此就需要将输出重定向到一个新的.i文件中去，所使用的命令如下所示。
	gcc -E hello.c > hello.i
	然后就会生成一个新的hello.i文件
	gcc -S hello.i 
	这一条命令不需要指定重定向的文件名字，gcc会自动创建一个新的hello.s文件，这就是一个汇编文件，最后执行
	gcc -c hello.s 
	就可以得到最后的可执行文件，可能教程中的gcc编译器的版本较早，当前的gcc编译器版本需要指定生成的.o文件才行
	gcc -c hello.s -o hello.o
	这样才会生成.o的目标文件
	最后再进行链接操作就可以生成可执行文件
	gcc hello.o -o hello
	然后就可以在目录中看到一个绿色的可执行文件了
	然后使用 ./hello 就可以执行当前目录下的hello可执行文件
	
	当然并不是每次都需要这样进行操作的，懒狗的方式就是直接
	gcc hello.c 
	运行这条命令的时候，gcc会默认将刚才的流程全部走一遍，在运行的过程中并没有任何的优化，并且在运行之后会默认生成一个a.out的文件。
	当然也可以指定可执行文件的文件名是什么
	gcc hello.c -o myhello
	这条命令相当于直接执行的刚才所有操作中的最后一步。
 	
	gcc hello.c -Wall
	这个选项的意思就是 all warnings ，这一条命令的作用就是输出所有的错误也就是warning，warning的含义就是这个显示的东西并不影响程序的运行，或者说是可执行文件的生成，但是gcc说话比较圆滑，所以说存在两种情况，一种就是gcc显示的错误就是单纯的错误，另一种就是真正的error了。程序在编译的过程中除非是你能够明确地知道并能够解释出这个警告出现的具体的原因，并且知道这个警告对程序的运行并没有什么影响，在这种情况下才可以不去管它，否则的话最好是把程序调试到没有任何警告为止。比如说定义了一个int i变量但是没有使用，这种警告就是没有影响的警告，因为一个进程在运行的时候就已经会占用非常多的内存空间了，当然说完全没有影响也不对，只能说这是一个几乎可以忽略不计的警告，但最好还是一个警告都不要出现，可能会有未定义的行为出现。
	
	在找不到函数原型的情况下，编译器会默认把函数的返回值当作是 int 整形，所以没有包括头文件的时候就有可能出现函数的返回值不匹配的这种警告的出现，这就是最底层的原理。	 

	
make:
	make相比于gcc的好处在于不会出现文件覆盖，比如说使用gcc用Tab自动补全的时候，gcc hello.c -o hello.c的时候源文件就会被直接覆盖掉，但是make后面直接跟的就是一个target目标文件，然后make会根据这个目标文件的名字去找相应的后缀是.c的源文件，然后自动调用cc hello.c -o hello 这样的一条命令，所以这个时候再使用自动补全的话，也不会出现源文件被覆盖的情况，因为这个时候相当于make去找的是hello.c.c这样的一个源文件，所以并不能找到这样的一个源文件，因此命令也就不会被执行了。


cc 是编译器的参数 默认是gcc

编辑器
vim:
	vim的配置文件和常用的快捷方式。
	一定要有意识地去使用vi和vim的快捷方式，但是不要刻意去记忆，在使用过程中继续记忆。
	vim的配置文件在vimrc中 /etc/vimrc 中
	最好的是将vimrc拷贝到家目录中
	cp /etc/vimrc ~/.vimrc
	etc目录下的vimrc是针对所有的用户有效，而家目录里面的文件是只对自己有效，并且设置成隐藏的就不会误操作了。代码对其的操作就是，先用ESC退出编辑模式，然后按下V进入可视化模式，选择代码之后按下等号就会自动对齐了。
	因为vimrc是在vim启动的时候运行的，所以重新启动vimrc即可重新导入新的配置,使用vim进行补全的操作就是用ctrl+P即可，然后如果想看某一个函数的手册的话，将光标放在想要查找的函数名字上面之后shift+K即可直接跳转到这个函数的man手册中，然后想要回到vim界面的话，就直接按两下Q键即可，非常方便。




 一、基本概念
1.以helloworld程序为例对写程序的思路提出如下要求:
	1）头文件包含的重要性
	2）以函数为单位来进行程序的编写
		涉及到多线程的内容时，其实main()就是线程的入口	
		比如说要写一个能够加减乘除的功能，如果说是都写在一个函数里面的话，在以后调用的时候会产生不必要的系统开销，但是携程加减乘除四个小的函数的话，就能够增加函数的复用性，减小了未来的工作量。至于说为什么要将函数打散或者是聚合在一起，还是看未来是否会调用这个功能或者说是函数，如果这么一段的代码在有可能需要调用的话，最好还是写开，但如果未来在编程的时候不太可能会用得到的话，将函数的代码都写在一起也能够增加代码的可维护性。	
	3）声明部分+实现部分
		在程序前方，头文件和函数的真正具体实现部分中间就是整个程序的声明部分，而在一个函数的上方就是一个函数的声明部分。
	4)return 0和exit(0)的区别
		return 0的意思是结束当前函数，而exit(0)的意思是结束当前进程，一般情况下来说，在单线程单进程中这两者几乎是没有什么区别的，需要注意的是return 0返回的是父进程也就是给父进程看的，不能说给Shell看的，在当前所学习的内容中，这个父进程就是Shell，并非完全是课本上面所说的操作系统，但并非所有程序的父进程都是Shell，这一点需要注意。具体的使用的话，可以用 echo $? 这个命令，它输出的是上一条命令的执行状态，如果 return 0 成功运行的话，那么很显然在终端上出现的就是 0 ,这个和Shell脚本的真假刚好是对立的，所以在这一点需要注意。其次需要注意的就是，假如说 hello.c 没有return 0 的语句的话，这个程序并不是会默认返回 0 的， 正常情况下返回为 0 ，然后在出错的情况下返回为非零值，这个只是程序员约定俗成的一个观念，并不是实际的情况，就这个程序本身而言，假如说没有return 语句的话，那么返回的应该是13，因为算上字母 空格 和换行符一共有13个，这个就是printf的返回值。






