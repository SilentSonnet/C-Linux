# 嵌入式工作总结

## conda换源

要为 `conda` 增加北京外国语大学的源，你可以按照以下步骤操作：

### 1. 打开终端或命令提示符

根据你的操作系统，打开相应的终端（Linux 或 macOS）或命令提示符（Windows）。

### 2. 备份现有的 `conda` 配置（可选）

在进行更改之前，建议备份当前的 `conda` 配置文件：

```bash
conda config --show-sources
```

### 3. 添加北京外国语大学的源

使用以下命令将北京外国语大学的源添加到 `conda` 配置中：

```bash
conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/main/
conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/free/
```

### 4. 设置源的优先级（可选）

如果你希望将北京外国语大学的源设置为优先使用，可以运行以下命令：

```bash
conda config --set channel_priority strict
```

### 5. 验证源是否添加成功

运行以下命令查看当前的 `conda` 配置，确保新源已添加：

```bash
conda config --show channels
```

你应该能看到类似如下的输出，其中包括刚刚添加的源：

```
channels:
  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/main/
  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/free/
  - defaults
```

### 6. 更新 `conda`（可选）

如果需要，更新 `conda` 以确保使用最新的版本：

```bash
conda update conda
```

现在，你已经成功为 `conda` 添加了北京外国语大学的源。如果有其他问题或需要进一步帮助，请随时告诉我！

## pip换源

要将 pip 的源更改为北京外国语大学的源，可以按照以下步骤进行操作：

### 1. 临时更改源

如果你只想在一次安装中使用北京外国语大学的源，可以在 pip 命令中使用 `-i` 选项，示例如下：

```bash
pip install 包名 -i https://pypi.bfsu.edu.cn/simple
```

将 `包名` 替换为你想安装的具体包。

### 2. 永久更改源

如果你希望永久更改 pip 的源，可以通过修改 `pip` 配置文件来实现。

#### Linux 或 macOS

1. 打开或创建 `~/.pip/pip.conf` 文件：

   ```bash
   mkdir -p ~/.pip
   nano ~/.pip/pip.conf
   ```

2. 添加以下内容：

   ```ini
   [global]
   index-url = https://pypi.bfsu.edu.cn/simple
   ```

3. 保存并退出。

#### Windows

1. 打开或创建 `%USERPROFILE%\pip\pip.ini` 文件：

   ```bash
   notepad %USERPROFILE%\pip\pip.ini
   ```

2. 添加以下内容：

   ```ini
   [global]
   index-url = https://pypi.bfsu.edu.cn/simple
   ```

3. 保存并关闭文件。

### 3. 验证更改

你可以通过以下命令检查当前配置的源：

```bash
pip config get global.index-url
```

如果显示为 `https://pypi.bfsu.edu.cn/simple`，说明源更改成功。

### 4. 更新 pip（可选）

在更改源后，你可能还想更新 pip，使用以下命令：

```bash
pip install --upgrade pip
```

这样就可以顺利使用北京外国语大学的 pip 源进行包管理了。如果有其他问题，请随时告诉我！

## VScode设置代理

在VS Code中设置代理有几个步骤，你可以通过以下方法来配置代理，以便VS Code能够正确地访问互联网和安装扩展等。

### 方法一：通过VS Code设置代理

1. **打开VS Code设置**：
   - 打开VS Code。
   - 点击左下角齿轮图标，选择 `Settings`。
   - 或者直接按 `Ctrl + ,` 快捷键打开设置。

2. **搜索代理设置**：
   - 在搜索栏中输入 `proxy`。

3. **设置HTTP和HTTPS代理**：
   - 找到 `Http: Proxy` 选项，并在右侧输入你的代理地址，例如 `http://username:password@proxy-server-address:port`。
   - 如果你的代理服务器需要认证，可以用 `username:password@proxy-server-address:port` 的格式填写。

4. **禁用严格SSL**（可选）：
   - 如果你的代理服务器是通过自签名证书或者你遇到SSL问题，你可以禁用严格SSL。
   - 搜索 `strict-ssl`，然后取消勾选 `Http: Proxy Strict SSL`。

### 方法二：通过命令行设置代理

1. **设置环境变量**：
   - 在命令行中设置HTTP和HTTPS代理环境变量。

   ```bash
   # Windows
   setx HTTP_PROXY http://username:password@proxy-server-address:port
   setx HTTPS_PROXY http://username:password@proxy-server-address:port
   
   # macOS/Linux
   export HTTP_PROXY=http://username:password@proxy-server-address:port
   export HTTPS_PROXY=http://username:password@proxy-server-address:port
   ```

2. **重启VS Code**：
   - 关闭并重新打开VS Code，使环境变量生效。

### 方法三：通过VS Code配置文件设置代理

1. **编辑用户设置文件**：
   - 打开VS Code设置，点击右上角的打开设置（JSON）图标。
   - 在 `settings.json` 文件中添加以下内容：

   ```json
   {
       "http.proxy": "http://username:password@proxy-server-address:port",
       "http.proxyStrictSSL": false
   }
   ```

### 方法四：配置扩展代理

有些扩展可能需要单独设置代理，例如GitLens。你可以在扩展的设置中找到代理配置选项。

### 示例配置

假设你的代理服务器地址是 `proxy.example.com`，端口是 `8080`，用户名是 `user`，密码是 `pass`。以下是不同设置的示例：

#### VS Code设置界面

- `Http: Proxy`：`http://user:pass@proxy.example.com:8080`
- 取消勾选 `Http: Proxy Strict SSL`。

#### settings.json文件

```json
{
    "http.proxy": "http://user:pass@proxy.example.com:8080",
    "http.proxyStrictSSL": false
}
```

#### 命令行

```bash
# Windows
setx HTTP_PROXY http://user:pass@proxy.example.com:8080
setx HTTPS_PROXY http://user:pass@proxy.example.com:8080

# macOS/Linux
export HTTP_PROXY=http://user:pass@proxy.example.com:8080
export HTTPS_PROXY=http://user:pass@proxy.example.com:8080
```

完成以上配置后，VS Code应该可以通过代理访问互联网并正常工作。如果遇到问题，可以检查代理设置是否正确，或者尝试重启VS Code以确保设置生效。

## 智能保温灯程序设计

​	项目需求是通过ESP12F控制器来连接WiFi后，再通过MQTT协议连接到公司的物联网平台，然后进行数据的上传和指令的接收，传输文件的格式我打算使用的是.json格式，然后需要通过PID算法来控制PWM波然后控制温度，温度传感器采用的是DS18B20，并且设置一个自动模式和手动模式，如 果是自动模式的话，就通过ESP12F内置的计数器和NTP来获取时间，计算当前日龄下，仔猪需要的温度应该是多少然后对温度来进行调节。我并不需要明确的代码，我想从大的软件架构的层面，寻求帮助。比如说我应该如何组织我的文件，那些功能应该用类写，应该放在一个头文件，那些应该分开等等。毕竟这个项目代码对我一个新手来说还是有点过于庞大了。

在设计您的ESP12F控制器项目时，从高层次的软件架构入手是一个明智的决定。以下是一个分步骤的指南，帮助您组织和规划项目文件以及类结构。

### 1. 项目目录结构

首先，定义项目的目录结构，以便于文件的管理和功能的模块化。以下是一个建议的目录结构：

```
/project-root
  ├── /src
  │   ├── main.cpp
  │   ├── config.h
  │   ├── WiFiManager.cpp
  │   ├── WiFiManager.h
  │   ├── MQTTClient.cpp
  │   ├── MQTTClient.h
  │   ├── TemperatureController.cpp
  │   ├── TemperatureController.h
  │   ├── DS18B20Sensor.cpp
  │   ├── DS18B20Sensor.h
  │   ├── PIDController.cpp
  │   ├── PIDController.h
  ├── /lib
  │   ├── /ArduinoJson
  │   ├── /PubSubClient
  │   ├── /OneWire
  │   ├── /DallasTemperature
  ├── /include
  └── platformio.ini
```

### 2. 文件及类结构

1. **main.cpp**
   - 入口文件，包含 `setup()` 和 `loop()` 函数。
   - 初始化各模块并管理主循环。

2. **config.h**
   - 配置文件，用于定义项目中的宏、常量和配置参数。
   - 例如，WiFi SSID和密码、MQTT服务器地址、NTP服务器地址等。

3. **WiFiManager.cpp / WiFiManager.h**
   - 管理WiFi连接的类。
   - 功能包括初始化WiFi、连接到指定的SSID和处理连接状态变化。

4. **MQTTClient.cpp / MQTTClient.h**
   - 管理MQTT连接的类。
   - 功能包括连接到MQTT服务器、订阅和发布消息、处理消息回调。

5. **TemperatureController.cpp / TemperatureController.h**
   - 温度控制的核心类，包含自动和手动模式的逻辑。
   - 负责读取温度传感器数据、计算目标温度和控制PWM输出。

6. **DS18B20Sensor.cpp / DS18B20Sensor.h**
   - 封装DS18B20温度传感器的操作类。
   - 功能包括初始化传感器、读取温度数据。

7. **PIDController.cpp / PIDController.h**
   - 封装PID控制算法的类。
   - 提供PID计算功能，输出PWM信号用于温度控制。

### 3. 类和函数定义

#### WiFiManager.h

```cpp
#ifndef WIFI_MANAGER_H
#define WIFI_MANAGER_H

#include <ESP8266WiFi.h>

class WiFiManager {
public:
    WiFiManager();
    void begin(const char* ssid, const char* password);
    bool isConnected();
private:
    const char* _ssid;
    const char* _password;
    void connect();
};

#endif // WIFI_MANAGER_H
```

#### MQTTClient.h

```cpp
#ifndef MQTT_CLIENT_H
#define MQTT_CLIENT_H

#include <PubSubClient.h>

class MQTTClient {
public:
    MQTTClient();
    void begin(const char* server, uint16_t port, WiFiClient& wifiClient);
    void loop();
    void publish(const char* topic, const char* payload);
    void subscribe(const char* topic);
private:
    PubSubClient _client;
    void onMessageReceived(char* topic, byte* payload, unsigned int length);
};

#endif // MQTT_CLIENT_H
```

#### TemperatureController.h

```cpp
#ifndef TEMPERATURE_CONTROLLER_H
#define TEMPERATURE_CONTROLLER_H

#include "DS18B20Sensor.h"
#include "PIDController.h"

class TemperatureController {
public:
    TemperatureController(DS18B20Sensor& sensor, PIDController& pid);
    void begin();
    void setMode(bool automatic);
    void setTargetTemperature(float targetTemp);
    void loop();
private:
    DS18B20Sensor& _sensor;
    PIDController& _pid;
    bool _automaticMode;
    float _targetTemperature;
    void controlTemperature();
};

#endif // TEMPERATURE_CONTROLLER_H
```

#### DS18B20Sensor.h

```cpp
#ifndef DS18B20_SENSOR_H
#define DS18B20_SENSOR_H

#include <OneWire.h>
#include <DallasTemperature.h>

class DS18B20Sensor {
public:
    DS18B20Sensor(uint8_t pin);
    void begin();
    float readTemperature();
private:
    OneWire _oneWire;
    DallasTemperature _sensors;
};

#endif // DS18B20_SENSOR_H
```

#### PIDController.h

```cpp
#ifndef PID_CONTROLLER_H
#define PID_CONTROLLER_H

class PIDController {
public:
    PIDController(float kp, float ki, float kd);
    float compute(float setpoint, float measuredValue);
private:
    float _kp, _ki, _kd;
    float _previousError;
    float _integral;
};

#endif // PID_CONTROLLER_H
```

### 4. 主程序逻辑

在 `main.cpp` 中，初始化各个模块并处理主循环。

```cpp
#include <Arduino.h>
#include "config.h"
#include "WiFiManager.h"
#include "MQTTClient.h"
#include "TemperatureController.h"
#include "DS18B20Sensor.h"
#include "PIDController.h"

// 全局对象
WiFiManager wifiManager;
WiFiClient espClient;
MQTTClient mqttClient;
DS18B20Sensor tempSensor(D2); // 假设传感器连接在D2引脚
PIDController pid(2.0, 5.0, 1.0);
TemperatureController tempController(tempSensor, pid);

void setup() {
    Serial.begin(115200);
    wifiManager.begin(WIFI_SSID, WIFI_PASSWORD);
    mqttClient.begin(MQTT_SERVER, MQTT_PORT, espClient);
    tempSensor.begin();
    tempController.begin();
    tempController.setMode(true); // 设置为自动模式
}

void loop() {
    if (wifiManager.isConnected()) {
        mqttClient.loop();
    }
    tempController.loop();
}
```

### 5. 配置文件

在 `config.h` 中定义项目中的常量和配置参数。

```cpp
#ifndef CONFIG_H
#define CONFIG_H

// WiFi配置
#define WIFI_SSID "your_ssid"
#define WIFI_PASSWORD "your_password"

// MQTT配置
#define MQTT_SERVER "your_mqtt_server"
#define MQTT_PORT 1883

// NTP服务器配置
#define NTP_SERVER "pool.ntp.org"

// 其他配置
#define TEMPERATURE_SENSOR_PIN D2

#endif // CONFIG_H
```

通过这种模块化的方法，您可以将项目分解为独立的功能模块，每个模块负责特定的任务。这不仅有助于代码的组织和管理，还使得代码的维护和扩展更加容易。每个模块都有自己的头文件和实现文件，头文件用于声明类和函数，实施文件用于定义具体的实现细节。这种方法可以帮助您更好地理解和管理代码结构。

## 面相对象编程和面相过程编程的区别

使用类进行开发与单纯使用函数进行开发之间存在几个关键区别，这些区别在代码组织、可维护性、扩展性和抽象层次上都有显著影响。

### 面向对象编程（OOP） vs 面向过程编程

#### 面向对象编程（OOP）

1. **封装性**：
   - 类将数据和操作数据的函数封装在一起，使得数据和函数成为一个整体。这样可以隐藏内部实现细节，只对外暴露接口，从而提高代码的安全性和可维护性。

2. **继承性**：
   - 类支持继承，可以创建新的类，从已有类继承属性和方法，重用代码。继承还允许多态的实现，使得相同接口可以有不同的实现。

3. **多态性**：
   - 通过多态性，子类可以定义自己的独特行为，同时也可以用作父类对象。这种特性在设计模式中非常重要，允许用同一个接口操作不同类型的对象。

4. **抽象性**：
   - 类和对象的使用使代码更接近现实世界的建模，能够更直观地表示问题域。

#### 面向过程编程

1. **模块化**：
   - 函数使代码模块化，减少重复代码，提高代码复用性。通过函数，可以将代码分成多个可重用的片段。

2. **简单性**：
   - 对于一些简单的问题或项目，面向过程编程可能更加直接和高效，容易理解和实现。

### 示例对比

#### 使用类进行开发

以下是使用类来开发的示例，展示了如何使用类来实现温度控制系统：

```cpp
#include <iostream>

class TemperatureSensor {
public:
    float readTemperature() {
        // 模拟读取温度
        return 25.0;
    }
};

class PIDController {
public:
    PIDController(float kp, float ki, float kd) : _kp(kp), _ki(ki), _kd(kd), _previousError(0), _integral(0) {}

    float compute(float setpoint, float measuredValue) {
        float error = setpoint - measuredValue;
        _integral += error;
        float derivative = error - _previousError;
        _previousError = error;
        return _kp * error + _ki * _integral + _kd * derivative;
    }

private:
    float _kp, _ki, _kd;
    float _previousError;
    float _integral;
};

class TemperatureController {
public:
    TemperatureController(TemperatureSensor& sensor, PIDController& pid) : _sensor(sensor), _pid(pid), _setpoint(25.0) {}

    void update() {
        float currentTemp = _sensor.readTemperature();
        float output = _pid.compute(_setpoint, currentTemp);
        // 这里控制PWM输出
        std::cout << "PWM Output: " << output << std::endl;
    }

    void setSetpoint(float setpoint) {
        _setpoint = setpoint;
    }

private:
    TemperatureSensor& _sensor;
    PIDController& _pid;
    float _setpoint;
};

int main() {
    TemperatureSensor sensor;
    PIDController pid(2.0, 5.0, 1.0);
    TemperatureController controller(sensor, pid);

    controller.update();
    return 0;
}
```

#### 使用函数进行开发

以下是使用函数来实现同样功能的示例：

```cpp
#include <iostream>

float readTemperature() {
    // 模拟读取温度
    return 25.0;
}

float computePID(float setpoint, float measuredValue, float kp, float ki, float kd, float& previousError, float& integral) {
    float error = setpoint - measuredValue;
    integral += error;
    float derivative = error - previousError;
    previousError = error;
    return kp * error + ki * integral + kd * derivative;
}

void controlTemperature(float setpoint, float kp, float ki, float kd) {
    static float previousError = 0;
    static float integral = 0;

    float currentTemp = readTemperature();
    float output = computePID(setpoint, currentTemp, kp, ki, kd, previousError, integral);

    // 这里控制PWM输出
    std::cout << "PWM Output: " << output << std::endl;
}

int main() {
    float setpoint = 25.0;
    float kp = 2.0, ki = 5.0, kd = 1.0;

    controlTemperature(setpoint, kp, ki, kd);
    return 0;
}
```

### 对比总结

1. **封装和抽象**：
   - 类可以更好地封装数据和功能，使代码更具有模块化和可维护性。面向过程编程虽然也可以通过函数实现模块化，但无法提供类的封装和抽象能力。

2. **代码复用和扩展**：
   - 类支持继承和多态，可以更方便地复用和扩展代码。面向过程编程在代码复用方面相对不如面向对象编程灵活。

3. **可读性和维护性**：
   - 使用类可以使代码结构更加清晰，易于理解和维护。面向过程编程在处理复杂系统时可能会使代码变得难以维护和扩展。

4. **开发效率**：
   - 对于复杂的系统，使用类可以提高开发效率和代码质量。对于简单任务或小型项目，面向过程编程可能更直接和高效。

综上所述，选择使用类还是函数取决于项目的复杂性和需求。对于复杂系统和长远的可维护性，建议使用面向对象编程。对于简单任务和小型项目，面向过程编程可能更合适。

## 给platformio换源的操作

要加快在CLion中使用PlatformIO创建工程的速度，可以通过更换源来实现。以下是详细步骤：

### 步骤一：安装PlatformIO

首先，确保你已经在CLion中安装了PlatformIO插件。如果没有，请按照以下步骤进行安装：

1. 打开CLion。
2. 进入 `File` -> `Settings` -> `Plugins`。
3. 在右上角的搜索框中输入`PlatformIO`，找到并安装插件。
4. 安装完成后，重启CLion。

### 步骤二：更换PlatformIO源

PlatformIO允许更换包管理器的源来加速下载速度。你可以通过以下步骤更换源：

1. **找到PlatformIO的配置文件**：

   在你的用户目录下找到PlatformIO的配置文件。文件路径通常是：
   - Windows: `C:\Users\<你的用户名>\.platformio\`
   - macOS/Linux: `/Users/<你的用户名>/.platformio/`

2. **创建或编辑配置文件**：

   在`.platformio`目录下创建或编辑文件`platformio.ini`，添加以下内容：

   ```ini
   [platformio]
   ; 更换为阿里云源
   registry = https://mirrors.aliyun.com/pypi/simple
   ```

3. **重启CLion**：

   修改完成后，重启CLion使配置生效。

### 步骤三：验证源配置

为了确保新的源配置生效，可以通过以下命令验证：

1. 打开CLion的终端（或者直接在系统终端中进行操作）。
2. 输入命令：`pio settings get`，检查`registry`是否已经被修改为新的源地址。

如果显示的信息中包含你配置的源地址，说明配置成功。

### 额外提示

1. **网络环境**：确保你的网络环境没有被防火墙或代理阻挡，否则可能仍然会影响下载速度。
2. **定期更新**：定期检查和更新PlatformIO以及相关工具，以保证你使用的是最新版本。

这样，通过更换源，应该能够显著提升在CLion中使用PlatformIO创建工程的速度。如果有任何问题，请随时反馈。

## 使用platformio进行ESP12F进行开发

​	使用platformio进行esp12f的开发时有可能会提示`clion报错A fatal error occurred: This chip is ESP8266 not ESP32. Wrong --chip argument?`出现这种情况的原因：

这个错误提示说明你在尝试为ESP8266模块编译或上传代码时，可能使用了错误的芯片参数（即把ESP8266误认为ESP32）。这是一个常见的问题，通常是因为PlatformIO的配置文件`platformio.ini`中的配置不正确导致的。

请按照以下步骤检查并修正你的`platformio.ini`文件：

### 步骤一：检查`platformio.ini`文件

1. 打开你的CLion项目。
2. 找到项目根目录下的`platformio.ini`文件。

### 步骤二：修改`platformio.ini`文件

确保你的`platformio.ini`文件配置正确，具体如下：

```ini
[env:nodemcuv2]
platform = espressif8266
board = nodemcuv2
framework = arduino
```

这个配置明确指定了`espressif8266`平台和`nodemcuv2`板子，这是适用于ESP8266（包括ESP-12F）的正确配置。

### 步骤三：清理项目

在PlatformIO中清理项目，以确保没有遗留的错误配置：

1. 在CLion中打开终端或使用PlatformIO集成的终端。
2. 运行以下命令清理项目：

   ```sh
   pio run --target clean
   ```

### 步骤四：重新编译和上传

清理项目后，重新编译并上传代码：

1. 在终端中运行以下命令进行编译和上传：

   ```sh
   pio run --target upload
   ```

或者在CLion的PlatformIO插件中使用“上传”按钮。

### 确认上传端口

确保在上传时指定了正确的端口。如果自动检测不到设备，可以在`platformio.ini`中添加端口信息：

```ini
[env:nodemcuv2]
platform = espressif8266
board = nodemcuv2
framework = arduino
upload_port = /dev/ttyUSB0  ; 或者COM3，视你的实际端口而定
```

通过以上步骤，你应该能够解决这个错误并成功地为ESP8266（ESP-12F）编译和上传代码。如果问题依旧，请检查是否有其他配置错误或驱动问题。如有进一步问题，请随时提问。

除此之外，在clion的platformio中进行开发的时候能够选择的板子数据：ESP-12E和ESP-12F都基于ESP8266芯片，二者在硬件上非常相似，主要差别在于天线的设计和射频性能的优化。因此，在大多数情况下，代码和配置对于ESP-12E和ESP-12F是兼容的。

在CLion中使用PlatformIO时，如果你选择ESP-12E作为开发板，大多数情况下也是兼容ESP-12F的。具体来说，你可以在PlatformIO的配置文件`platformio.ini`中选择`nodemcuv2`或者直接选择`esp12e`板子类型。

### 配置PlatformIO

在你的`platformio.ini`文件中，可以选择如下配置：

#### 选择NodeMCU v2开发板（推荐）

```ini
[env:nodemcuv2]
platform = espressif8266
board = nodemcuv2
framework = arduino
```

#### 选择ESP-12E开发板

```ini
[env:esp12e]
platform = espressif8266
board = esp12e
framework = arduino
```

### 确保兼容性的注意事项

1. **引脚配置**：检查你的代码中是否使用了ESP-12E或ESP-12F特有的引脚。如果有特定的引脚配置，确保这些引脚在两块板子上是相同的。
2. **硬件连接**：确保你的硬件连接和外设配置兼容ESP-12F的引脚布局。
3. **天线设计**：尽管ESP-12F的射频性能优化了，但一般在大多数应用中无需做额外调整。

### 示例`platformio.ini`配置

下面是一个通用的`platformio.ini`文件示例，适用于ESP-12E和ESP-12F：

```ini
[env:esp12e]
platform = espressif8266
board = esp12e
framework = arduino
upload_speed = 115200
monitor_speed = 115200

; 如果使用nodemcuv2开发板，可以使用下面的配置
; [env:nodemcuv2]
; platform = espressif8266
; board = nodemcuv2
; framework = arduino
; upload_speed = 115200
; monitor_speed = 115200
```

### 总结

ESP-12E和ESP-12F在硬件和软件上的兼容性非常高，所以在CLion中选择ESP-12E作为开发板通常也能兼容ESP-12F。如果你的项目没有特定的天线或射频要求，使用`esp12e`或`nodemcuv2`作为开发板类型是完全可以的。如果有其他具体问题或需要进一步的帮助，请随时提问。

### esp12f和Arduino的WiFi.h文件不兼容的问题

在将项目从Arduino Uno R4 WiFi迁移到ESP-12F时，由于ESP-12F基于ESP8266芯片，WiFi库需要使用适用于ESP8266的WiFi库。Arduino的`WiFi.h`库是为ESP8266和ESP32设计的，但你需要确保使用的是正确的版本并进行一些调整。

对于ESP8266，你应该使用`ESP8266WiFi`库，而不是`WiFi.h`库。以下是详细的步骤，帮助你将代码从Arduino Uno R4 WiFi迁移到ESP-12F：

### 步骤一：更新库引用

将所有的`WiFi.h`头文件引用替换为`ESP8266WiFi.h`。例如：

```cpp
#include <ESP8266WiFi.h>
```

### 步骤二：调整代码

在使用ESP8266WiFi库时，大部分代码逻辑可以保持不变，但需要做一些小调整。以下是一个示例代码，展示了如何连接到WiFi网络：

#### Arduino Uno R4 WiFi代码示例

```cpp
#include <WiFi.h>

const char* ssid = "your_SSID";
const char* password = "your_PASSWORD";

void setup() {
    Serial.begin(115200);
    WiFi.begin(ssid, password);

    while (WiFi.status() != WL_CONNECTED) {
        delay(1000);
        Serial.println("Connecting to WiFi...");
    }

    Serial.println("Connected to WiFi");
}

void loop() {
    // Your code here
}
```

#### ESP-12F（ESP8266）代码示例

```cpp
#include <ESP8266WiFi.h>

const char* ssid = "your_SSID";
const char* password = "your_PASSWORD";

void setup() {
    Serial.begin(115200);
    WiFi.begin(ssid, password);

    while (WiFi.status() != WL_CONNECTED) {
        delay(1000);
        Serial.println("Connecting to WiFi...");
    }

    Serial.println("Connected to WiFi");
}

void loop() {
    // Your code here
}
```

### 步骤三：检查WiFi功能

ESP8266WiFi库提供了丰富的WiFi功能，与Arduino的WiFi库相似，可以实现WiFi连接、服务器创建、客户端连接等功能。以下是一些常用的功能和代码示例：

#### 连接到WiFi网络

```cpp
#include <ESP8266WiFi.h>

const char* ssid = "your_SSID";
const char* password = "your_PASSWORD";

void setup() {
    Serial.begin(115200);
    WiFi.begin(ssid, password);

    while (WiFi.status() != WL_CONNECTED) {
        delay(1000);
        Serial.println("Connecting to WiFi...");
    }

    Serial.println("Connected to WiFi");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
}

void loop() {
    // Your code here
}
```

#### 创建WiFi热点（AP模式）

```cpp
#include <ESP8266WiFi.h>

const char* ssid = "ESP8266_AP";
const char* password = "your_PASSWORD";

void setup() {
    Serial.begin(115200);

    WiFi.softAP(ssid, password);

    Serial.println("WiFi AP started");
    Serial.print("IP Address: ");
    Serial.println(WiFi.softAPIP());
}

void loop() {
    // Your code here
}
```

### 步骤四：编译和上传代码

1. 确保在`platformio.ini`中配置了正确的开发板和框架。
2. 在CLion中编写并保存你的代码。
3. 使用PlatformIO的编译和上传功能将代码烧录到ESP-12F模块中。

通过这些步骤，你可以成功地将Arduino Uno R4 WiFi项目迁移到ESP-12F，并确保WiFi功能正常运行。如果有其他具体问题或需要进一步的帮助，请随时提问。

## Arduino实现设备心跳

## Arduino实现软串口

在 ESP-12F（基于 ESP8266）上，GPIO16 和 GPIO13 可以用作软件串口（SoftwareSerial），但有一些注意事项：

### GPIO16
- GPIO16 连接到 ESP8266 的深度睡眠唤醒引脚（RTC）上，它不支持中断，并且其功能有限。
- 通常用于连接到外部复位电路以从深度睡眠中唤醒设备。
- 由于它的硬件限制，不推荐用于软件串口通信，因为其功能受限且不支持中断。

### GPIO13
- GPIO13 是一个常规的 GPIO 引脚，支持中断，可以用作 SoftwareSerial。
- 它是 ESP8266 上比较通用的 GPIO 引脚，通常用于 I/O 操作。

### 使用 SoftwareSerial
如果你想在 ESP-12F 上使用软件串口，可以使用 `SoftwareSerial` 库，该库允许你在支持中断的 GPIO 引脚上创建额外的串口。

以下是一个示例代码，展示如何在 GPIO13 上使用软件串口：

```cpp
#include <SoftwareSerial.h>

// 定义 RX 和 TX 引脚
const int RX_PIN = 13;
const int TX_PIN = 12;  // 可以选择其他支持的 GPIO 引脚

// 创建 SoftwareSerial 对象
SoftwareSerial mySerial(RX_PIN, TX_PIN);

void setup() {
    // 初始化硬件串口
    Serial.begin(115200);
    // 初始化软件串口
    mySerial.begin(9600);

    Serial.println("Software Serial Example");
}

void loop() {
    // 从软件串口读取数据并输出到硬件串口
    if (mySerial.available()) {
        char c = mySerial.read();
        Serial.write(c);
    }

    // 从硬件串口读取数据并输出到软件串口
    if (Serial.available()) {
        char c = Serial.read();
        mySerial.write(c);
    }
}
```

### 总结
- **GPIO16** 不适合用于软件串口。
- **GPIO13** 可以用作软件串口，且支持中断。
- 使用 `SoftwareSerial` 库可以在支持中断的 GPIO 引脚上创建额外的串口。

### 参考资料
- [ESP8266 GPIO功能](https://randomnerdtutorials.com/esp8266-pinout-reference-gpios/)
- [SoftwareSerial 库](https://www.arduino.cc/en/Reference/softwareSerial)

通过这些参考资料，你可以更好地了解如何在 ESP-12F 上配置和使用软件串口。

## 常见编译错误

1.src\src\setting.cpp:7:1: error: redefinition of 'SmartLamp::SmartLamp(arduino::String)'

这个错误可能是因为头文件的多重包含没有正确处理。可以通过添加头文件保护（即 `#ifndef`，`#define` 和 `#endif`）来避免这种问题。此外，也要确保类定义中的构造函数没有重复定义。

我已经在头文件中添加了头文件保护符号，再检查一下构造函数的定义。

2.expected declarator name

"expected declarator name" 错误通常发生在 C 或 C++ 编程中，当编译器在声明或定义中遇到意外内容时会出现此错误。导致这种错误的原因可能有多种，比如语法错误、缺少分号、关键字使用不当或代码元素的位置不正确。以下是一些常见原因及其解决方法：

1. **缺少分号**:
    - 确保每个语句都以分号 (`;`) 结束。
    ```cpp
    int a = 5 // 错误: 缺少分号
    int b = 10;
    ```

2. **关键字使用不当**:
    - 确保没有错误地使用保留关键字。
    ```cpp
    int class = 5; // 错误: 'class' 是保留关键字
    ```

3. **声明中的拼写错误**:
    - 检查变量或函数声明中的拼写错误或语法错误。
    ```cpp
    int x 5; // 错误: 缺少 '=' 或其他操作符
    int y = 10;
    ```

4. **括号或大括号不匹配**:
    - 确保所有的大括号 `{}`、圆括号 `()` 和方括号 `[]` 都正确匹配并关闭。
    ```cpp
    if (x > 0 { // 错误: 缺少闭合圆括号
        x = x + 1;
    }
    ```

5. **代码位置不正确**:
    - 确保声明在代码结构中的位置正确。
    ```cpp
    void myFunction() {
        int a = 5;
    }
    int b = 10; // 这是正确的
    void anotherFunction() {
        int c = 20;
    }
    ```

6. **头文件中的包含保护**:
    - 如果使用头文件，确保有正确的包含保护以防止多次包含。
    ```cpp
    #ifndef MY_HEADER_H
    #define MY_HEADER_H
    
    // 你的声明
    
    #endif
    ```

7. **模板语法不正确**:
    - 确保使用模板时的语法正确。
    ```cpp
    template<typename T>
    void myFunction(T param) {
        // 函数实现
    }
    ```

如果你仍然遇到 "expected declarator name" 错误，请提供发生错误的代码片段，以便获得更具体的帮助。

3.如果在嵌入式的编程中，

## HLW8110的驱动代码 Arduino实现

好的，下面是完整的转换后的 `HLW8110.cpp` 文件内容，包括所有函数的实现。

### 转换后的 `HLW8110.cpp` 文件

```cpp
#include "HLW8110.h"

// 定义全局变量
volatile uint8_t u8_RxBuf[RX_BUF_LENGTH];
volatile uint8_t u8_TxBuf[TX_BUF_LENGTH];
volatile uint8_t u8_TX_Length = 0;
volatile uint8_t u8_RX_Length = 0;
volatile uint8_t u8_RX_Index = 0;
volatile bool B_Rx_Data_ING = false;
volatile bool B_Rx_Finish = false;
volatile bool B_Read_Error = false;

uint16_t U16_RMSIAC_RegData;
uint16_t U16_RMSIBC_RegData;
uint16_t U16_RMSUC_RegData;
uint16_t U16_PowerPAC_RegData;
uint16_t U16_PowerPBC_RegData;
uint16_t U16_PowerSC_RegData;
uint16_t U16_EnergyAC_RegData;
uint16_t U16_EnergyBC_RegData;
uint16_t U16_CheckSUM_RegData;
uint16_t U16_CheckSUM_Data;

uint32_t U32_RMSIA_RegData;
uint32_t U32_RMSU_RegData;
uint32_t U32_POWERPA_RegData;
uint32_t U32_ENERGY_PA_RegData;

float F_AC_V;
float F_AC_I;
float F_AC_P;
float F_AC_E;
float F_AC_BACKUP_E;
float F_AC_PF;
float F_Angle;
float F_AC_LINE_Freq;



// 模拟 USART 中断处理函数
void USART2_IRQHandler() {
    // 接收数据
    if (Serial.available()) {
        if (u8_RX_Index < u8_RX_Length) {
            u8_RxBuf[u8_RX_Index] = Serial.read(); // 数据接收中
            u8_RX_Index++;
            B_Rx_Data_ING = true; // 置数据接收标志位
        } else {
            B_Rx_Finish = true; // 数据接收完毕
            u8_RX_Index = 0;
        }
    }
}

// UART 发送数据
void Start_Send_UartData(uint8_t len) {
    for (uint8_t i = 0; i < len; i++) {
        Serial.write(u8_TxBuf[i]);
        while (!Serial.availableForWrite()); // 等待发送结束
    }
}

// 清空接收缓存器的数据
void Clear_RxBuf() {
    for (uint8_t i = 0; i < RX_BUF_LENGTH; i++) {
        u8_RxBuf[i] = 0x00;
    }
    B_Rx_Data_ING = false;
    B_Rx_Finish = false;
    u8_RX_Index = 0;
}

// 写寄存器的校验和计算
uint8_t HLW8110_checkSum_Write(uint8_t u8_Reg_length) {
    uint32_t a = 0x0000;
    for (uint8_t i = 0; i < (u8_Reg_length - 1); i++) {
        a += u8_TxBuf[i];
    }
    a = ~a;
    return a & 0xff;
}

// 读寄存器的校验和计算
uint8_t HLW8110_checkSum_Read(uint8_t u8_Reg_length) {
    uint32_t a = 0x0000;
    for (uint8_t i = 0; i < (u8_Reg_length - 1); i++) {
        a += u8_RxBuf[i];
    }
    a = a + u8_TxBuf[0] + u8_TxBuf[1];
    a = ~a;
    return a & 0xff;
}

// 启用寄存器写功能
void Uart_HLW8110_WriteREG_EN() {
    u8_TX_Length = 4;
    u8_RX_Length = 0;
    u8_TxBuf[0] = 0xa5;
    u8_TxBuf[1] = 0xea;
    u8_TxBuf[2] = 0xe5;
    u8_TxBuf[3] = HLW8110_checkSum_Write(u8_TX_Length);
    Start_Send_UartData(u8_TX_Length);
}

// 禁用寄存器写功能
void Uart_HLW8110_WriteREG_DIS() {
    u8_TX_Length = 4;
    u8_RX_Length = 0;
    u8_TxBuf[0] = 0xa5;
    u8_TxBuf[1] = 0xea;
    u8_TxBuf[2] = 0xdc;
    u8_TxBuf[3] = HLW8110_checkSum_Write(u8_TX_Length);
    Start_Send_UartData(u8_TX_Length);
}

// 设置通道A
void Uart_HLW8110_Set_Channel_A() {
    u8_TX_Length = 4;
    u8_RX_Length = 0;
    u8_TxBuf[0] = 0xa5;
    u8_TxBuf[1] = 0xea;
    u8_TxBuf[2] = 0x5a;
    u8_TxBuf[3] = HLW8110_checkSum_Write(u8_TX_Length);
    Start_Send_UartData(u8_TX_Length);
}

// 读取寄存器
void Uart_Read_HLW8110_Reg(uint8_t ADDR_Reg, uint8_t u8_reg_length) {
    u8_TxBuf[0] = 0xa5;
    u8_TxBuf[1] = ADDR_Reg;
    u8_TX_Length = 2;
    u8_RX_Length = u8_reg_length + 1; // +1，因为接收的数据长度，除了REG值，还有一个校验和数据
    Clear_RxBuf(); // 清空接收缓冲区
    Start_Send_UartData(u8_TX_Length);
}

// 写寄存器
void Uart_Write_HLW8110_Reg(uint8_t ADDR_Reg, uint8_t u8_reg_length, uint32_t u32_data) {
    union LongData {
        uint32_t word;
        uint8_t byte[4];
    } Temp_u32_a;

    u8_TxBuf[0] = 0xa5;
    u8_TxBuf[1] = ADDR_Reg | 0x80;
    Temp_u32_a.word = u32_data;

    for (uint8_t i = 0; i < u8_reg_length; i++) {
        u8_TxBuf[i + 2] = Temp_u32_a.byte[u8_reg_length - 1 - i];
    }

    u8_TX_Length = 3 + u8_reg_length;
    u8_RX_Length = 0;
    u8_TxBuf[u8_TX_Length - 1] = HLW8110_checkSum_Write(u8_TX_Length);
    Start_Send_UartData(u8_TX_Length);
}

// 复位
void Uart_HLW8110_Reset() {
    u8_TX_Length = 4;
    u8_RX_Length = 0;
    u8_TxBuf[0] = 0xa5;
    u8_TxBuf[1] = 0xea;
    u8_TxBuf[2] = 0x96;
    u8_TxBuf[3] = HLW8110_checkSum_Write(u8_TX_Length);
    Start_Send_UartData(u8_TX_Length);
}

// 检查校验和
uint8_t Judge_CheckSum_HLW8110_Calfactor() {
    uint32_t a = 0xffff;
    uint16_t b, c;
    uint8_t d;

    // 读取寄存器数据
    Uart_Read_HLW8110_Reg(REG_RMS_IAC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_RMSIAC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("A通道电流转换系数: " + String(U16_RMSIAC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_RMS_IBC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_RMSIBC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("B通道电流转换系数: " + String(U16_RMSIBC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_RMS_UC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_RMSUC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("电压通道转换系数: " + String(U16_RMSUC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_POWER_PAC_ADDR, 2);
    delay(50);
    if (u8_Rx

Buf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_PowerPAC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("A通道功率转换系数: " + String(U16_PowerPAC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_POWER_PBC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_PowerPBC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("B通道功率转换系数: " + String(U16_PowerPBC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_POWER_SC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_PowerSC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("视在功率转换系数: " + String(U16_PowerSC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_ENERGY_AC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_EnergyAC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("A通道电量转换系数: " + String(U16_EnergyAC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_ENERGY_BC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_EnergyBC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("B通道电量转换系数: " + String(U16_EnergyBC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_CHECKSUM_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_CheckSUM_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("系数校验和: " + String(U16_CheckSUM_RegData, HEX));
    }

    a = ~(0xffff + U16_RMSIAC_RegData + U16_RMSIBC_RegData + U16_RMSUC_RegData +
          U16_PowerPAC_RegData + U16_PowerPBC_RegData + U16_PowerSC_RegData +
          U16_EnergyAC_RegData + U16_EnergyBC_RegData);
    U16_CheckSUM_Data = a & 0xffff;

    Serial.println("计算系数校验和: " + String(U16_CheckSUM_Data, HEX));

    if (U16_CheckSUM_Data == U16_CheckSUM_RegData) {
        d = 1;
        Serial.println("校验和正确");
    } else {
        d = 0;
        Serial.println("校验和出错");
    }

    return d;
}

// 初始化 HLW8110
void Init_HLW8110() {
    // 初始化 UART
    Serial.begin(9600);

    // 设置 IO
    pinMode(A0, OUTPUT); // 示例 IO 引脚
    pinMode(A1, OUTPUT);
    digitalWrite(A0, LOW);
    digitalWrite(A1, HIGH);

    Uart_HLW8110_WriteREG_EN();
    delay(10);

    Uart_HLW8110_Set_Channel_A();
    delay(10);

    Uart_Write_HLW8110_Reg(REG_SYSCON_ADDR, 2, 0x0a04);
    delay(10);

    Uart_Write_HLW8110_Reg(REG_EMUCON_ADDR, 2, 0x0001);
    Uart_Write_HLW8110_Reg(REG_EMUCON2_ADDR, 2, 0x0465);
    delay(10);

    Uart_HLW8110_WriteREG_DIS();
    Judge_CheckSum_HLW8110_Calfactor();
}

// 检验写入的 REG 是否正确写入
void Check_WriteReg_Success() {
    Uart_Read_HLW8110_Reg(REG_SYSCON_ADDR, 2);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_Check_SysconReg_Data = (u8_RxBuf[0] << 8) + (u8_RxBuf[1]);
        Serial.println("写入的SysconReg寄存器: " + String(U16_Check_SysconReg_Data, HEX));
    } else {
        Serial.println("SysconReg寄存器读取出错");
        B_Read_Error = 1;
    }

    Uart_Read_HLW8110_Reg(REG_EMUCON_ADDR, 2);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_Check_EmuconReg_Data = (u8_RxBuf[0] << 8) + (u8_RxBuf[1]);
        Serial.println("写入的EmuconReg寄存器: " + String(U16_Check_EmuconReg_Data, HEX));
    } else {
        Serial.println("EmuconReg寄存器读取出错");
        B_Read_Error = 1;
    }

    Uart_Read_HLW8110_Reg(REG_EMUCON2_ADDR, 2);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_Check_Emucon2Reg_Data = (u8_RxBuf[0] << 8) + (u8_RxBuf[1]);
        Serial.println("写入的Emucon2Reg寄存器: " + String(U16_Check_Emucon2Reg_Data, HEX));
    } else {
        Serial.println("Emucon2Reg寄存器读取出错");
        B_Read_Error = 1;
    }
}

// 读取A通道电流
void Read_HLW8110_IA() {
    float a;

    Uart_Read_HLW8110_Reg(REG_RMSIA_ADDR, 3);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U32_RMSIA_RegData = (uint32_t)(u8_RxBuf[0] << 16) + (uint32_t)(u8_RxBuf[1] << 8) + (uint32_t)(u8_RxBuf[2]);
        Serial.println("A通道电流寄存器: " + String(U32_RMSIA_RegData, HEX));
    } else {
        Serial.println("A通道电流寄存器读取出错");
        B_Read_Error = 1;
    }

    if ((U32_RMSIA_RegData & 0x800000) == 0x800000) {
        F_AC_I = 0;
    } else {
        a = (float)U32_RMSIA_RegData;
        a = a * U16_RMSIAC_RegData;
        a = a / 0x800000; // 电流计算出来的浮点数单位是mA, 比如5003.12
        a = a / 1; // 1 = 电流系数
        a = a / 1000; // a = 5003mA, a / 1000 = 5.003A, 单位转换成A
        a = a * D_CAL_A_I; // D_CAL_A_I是校正系数，默认是1
        F_AC_I = a;
    }
}

// 读取电压
void Read_HLW8110_U() {
    float a;

    Uart_Read_HLW8110_Reg(REG_RMSU_ADDR, 3);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U32_RMSU_RegData = (uint32_t)(u8_RxBuf[0] << 16) + (uint32_t)(u8_RxBuf[1] << 8) + (uint32_t)(u8_RxBuf[2]);
        Serial.println("电压通道寄存器: " + String(U32_RMSU_RegData, HEX));
    } else {
        Serial.println("电压通道寄存器读取出错");
        B_Read_Error = 1;
    }

    if ((U32_RMSU_RegData & 0x800000

) == 0x800000) {
        F_AC_V = 0;
    } else {
        a = (float)U32_RMSU_RegData;
        a = a * U16_RMSUC_RegData;
        a = a / 0x400000;
        a = a / 1; // 1 = 电压系数
        a = a / 100; // 计算出a = 22083.12mV, a / 100表示220.8312V，电压转换成V
        a = a * D_CAL_U; // D_CAL_U是校正系数，默认是1
        F_AC_V = a;
    }
}

// 读取A通道功率
void Read_HLW8110_PA() {
    float a, b;

    Uart_Read_HLW8110_Reg(REG_POWER_PA_ADDR, 4);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U32_POWERPA_RegData = (uint32_t)(u8_RxBuf[0] << 24) + (uint32_t)(u8_RxBuf[1] << 16) + (uint32_t)(u8_RxBuf[2] << 8) + (uint32_t)(u8_RxBuf[3]);
        Serial.println("A通道功率寄存器: " + String(U32_POWERPA_RegData, HEX));
    } else {
        Serial.println("A通道功率寄存器读取出错");
        B_Read_Error = 1;
    }

    if (U32_POWERPA_RegData > 0x80000000) {
        b = ~U32_POWERPA_RegData;
        a = (float)b;
    } else {
        a = (float)U32_POWERPA_RegData;
    }

    a = a * U16_PowerPAC_RegData;
    a = a / 0x80000000;
    a = a / 1; // 1 = 电流系数
    a = a / 1; // 1 = 电压系数
    a = a * D_CAL_A_P; // D_CAL_A_P是校正系数，默认是1
    F_AC_P = a; // 单位为W,比如算出来5000.123，表示5000.123W
}

// 读取A通道有功电量
void Read_HLW8110_EA() {
    float a;

    Uart_Read_HLW8110_Reg(REG_ENERGY_PA_ADDR, 3);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U32_ENERGY_PA_RegData = (uint32_t)(u8_RxBuf[0] << 16) + (uint32_t)(u8_RxBuf[1] << 8) + (uint32_t)(u8_RxBuf[2]);
        Serial.println("A通道有功电量寄存器: " + String(U32_ENERGY_PA_RegData, HEX));
    } else {
        Serial.println("A通道有功电量寄存器读取出错");
        B_Read_Error = 1;
    }

    Uart_Read_HLW8110_Reg(REG_HFCONST_ADDR, 2);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        U16_HFConst_RegData = (uint16_t)(u8_RxBuf[0] << 8) + (uint16_t)(u8_RxBuf[1]);
        Serial.println("HFCONST常数: " + String(U16_HFConst_RegData));
    } else {
        Serial.println("HFCONST常数寄存器读取出错");
        B_Read_Error = 1;
    }

    a = (float)U32_ENERGY_PA_RegData;
    a = a * U16_EnergyAC_RegData;
    a = a / 0x20000000; // 电量单位是0.001KWH,比如算出来是2.002,表示2.002KWH
    a = a / 1; // 1 = 电流系数
    a = a / 1; // 1 = 电压系数
    a = a * D_CAL_A_E; // D_CAL_A_E是校正系数，默认是1
    F_AC_E = a;
    F_AC_BACKUP_E = F_AC_E;
}

// 读取A通道的线性频率
void Read_HLW8110_LineFreq() {
    float a;
    uint32_t b;

    Uart_Read_HLW8110_Reg(REG_UFREQ_ADDR, 2);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        b = (uint32_t)(u8_RxBuf[0] << 8) + (uint32_t)(u8_RxBuf[1]);
        Serial.println("A通道线性频率寄存器: " + String(b));
    } else {
        Serial.println("A通道线性频率寄存器读取出错");
        B_Read_Error = 1;
    }

    a = (float)b;
    a = 3579545 / (8 * a);
    F_AC_LINE_Freq = a;
}

// 读取功率因素
void Read_HLW8110_PF() {
    float a;
    uint32_t b;

    Uart_Read_HLW8110_Reg(REG_PF_ADDR, 3);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        b = (uint32_t)(u8_RxBuf[0] << 16) + (uint32_t)(u8_RxBuf[1] << 8) + (uint32_t)(u8_RxBuf[2]);
        Serial.println("A通道功率因素寄存器: " + String(b));
    } else {
        Serial.println("读取A通道功率因素寄存器出错");
        B_Read_Error = 1;
    }

    if (b > 0x800000) { // 为负，容性负载
        a = (float)(0xffffff - b + 1) / 0x7fffff;
    } else {
        a = (float)b / 0x7fffff;
    }

    if (F_AC_P < 0.3) { // 小于0.3W，空载或小功率，PF不准
        a = 0;
    }

    F_AC_PF = a;
}

// 读取相位角
void Read_HLW8110_Angle() {
    float a;
    uint32_t b;

    Uart_Read_HLW8110_Reg(REG_ANGLE_ADDR, 2);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length)) {
        b = (uint32_t)(u8_RxBuf[0] << 8) + (uint32_t)(u8_RxBuf[1]);
        Serial.println("A通道线相角寄存器: " + String(b));
    } else {
        Serial.println("A通道线相角寄存器读取出错");
        B_Read_Error = 1;
    }

    if (F_AC_PF < 55) { // 线性频率50HZ
        a = b;
        a = a * 0.0805;
        F_Angle = a;
    } else {
        // 线性频率60HZ
        a = b;
        a = a * 0.0965;
        F_Angle = a;
    }

    if (F_AC_P < 0.5) { // 功率小于0.5时，说明没有负载，相角为0
        F_Angle = 0;
    }

    if (F_Angle < 90) {
        a = F_Angle;
        Serial.println("电流超前电压: " + String(a));
    } else if (F_Angle < 180) {
        a = 180 - F_Angle;
        Serial.println("电流滞后电压: " + String(a));
    } else if (F_Angle < 360) {
        a = 360 - F_Angle;
        Serial.println("电流滞后电压: " + String(a));
    } else {
        a = F_Angle - 360;
        Serial.println("电流超前电压: " + String(a));
    }
}

// 计算HLW8110电表数据
void Calculate_HLW8110_MeterData() {
    Check_WriteReg_Success();
    
    Read_HLW8110_IA();
    Read_HLW8110_U();
    Read_HLW8110_PA();
    Read_HLW8110_EA();
    
    Read_HLW8110_LineFreq();
    Read_HLW8110_Angle();
    Read_HLW8110_PF();
    
    Serial.println();
    Serial.println();
    Serial.println("交流测量,uart

通讯方式");
    Serial.println("A通道电流转换系数: " + String(U16_RMSIAC_RegData, HEX));
    Serial.println("B通道电流转换系数: " + String(U16_RMSIBC_RegData, HEX));
    Serial.println("电压通道转换系数: " + String(U16_RMSUC_RegData, HEX));
    Serial.println("A通道功率转换系数: " + String(U16_PowerPAC_RegData, HEX));
    Serial.println("B通道功率转换系数: " + String(U16_PowerPBC_RegData, HEX));
    Serial.println("视在功率转换系数: " + String(U16_PowerSC_RegData, HEX));
    Serial.println("A通道电量转换系数: " + String(U16_EnergyAC_RegData, HEX));
    Serial.println("B通道电量转换系数: " + String(U16_EnergyBC_RegData, HEX));
    Serial.println("转换系数校验和: " + String(U16_CheckSUM_RegData, HEX));
    Serial.println("转换系数计算出的校验和: " + String(U16_CheckSUM_Data, HEX));
    
    Serial.println();
    Serial.println("A通道电流寄存器: " + String(U32_RMSIA_RegData, HEX));
    Serial.println("电压寄存器: " + String(U32_RMSU_RegData, HEX));
    Serial.println("A通道功率寄存器: " + String(U32_POWERPA_RegData, HEX));
    Serial.println("A通道电量寄存器: " + String(U32_ENERGY_PA_RegData, HEX));
    
    Serial.println();
    Serial.println("F_AC_I = " + String(F_AC_I) + " A");
    Serial.println("F_AC_V = " + String(F_AC_V) + " V");
    Serial.println("F_AC_P = " + String(F_AC_P) + " W");
    Serial.println("F_AC_BACKUP_E = " + String(F_AC_BACKUP_E) + " KWH");
    Serial.println("F_AC_LINE_Freq = " + String(F_AC_LINE_Freq) + " Hz");
    Serial.println("F_Angle = " + String(F_Angle));
    Serial.println("F_AC_PF = " + String(F_AC_PF));
    
    Serial.println();
    Serial.println();
    Serial.println("----------------------------------------------");
    Serial.println("----------------------------------------------");
}
```

### 示例主程序

```cpp
#include "HLW8110.h"

void setup() {
    Serial.begin(115200);
    Init_HLW8110();
    Serial.println("HLW8110 Initialized");
}

void loop() {
    // 调用库函数
    Read_HLW8110_IA();
    Read_HLW8110_U();
    Read_HLW8110_PA();
    Read_HLW8110_EA();
    Read_HLW8110_LineFreq();
    Read_HLW8110_Angle();
    Read_HLW8110_PF();
    
    Calculate_HLW8110_MeterData();
    
    delay(1000);
}
```

请将这些代码保存为 `HLW8110.h` 和 `HLW8110.cpp` 文件，并将它们放置在 Arduino 库文件夹中（例如 `Documents/Arduino/libraries/HLW8110`），然后在你的 Arduino 项目中使用该库。这样你就可以在Arduino开发板上运行这些代码了。



好的，下面是将你的STM32代码转换为Arduino格式的完整示例，并保持函数形式供主程序调用。

### 转换后的 `HLW8110.h` 文件

```cpp
#ifndef HLW8110_H
#define HLW8110_H

#include <Arduino.h>

// 定义缓冲区长度
#define RX_BUF_LENGTH 10
#define TX_BUF_LENGTH 10

// 定义全局变量
extern volatile uint8_t u8_RxBuf[RX_BUF_LENGTH];
extern volatile uint8_t u8_TxBuf[TX_BUF_LENGTH];
extern volatile uint8_t u8_TX_Length;
extern volatile uint8_t u8_RX_Length;
extern volatile uint8_t u8_RX_Index;
extern volatile bool B_Rx_Data_ING;
extern volatile bool B_Rx_Finish;
extern volatile bool B_Read_Error;

extern uint16_t U16_RMSIAC_RegData;
extern uint16_t U16_RMSIBC_RegData;
extern uint16_t U16_RMSUC_RegData;
extern uint16_t U16_PowerPAC_RegData;
extern uint16_t U16_PowerPBC_RegData;
extern uint16_t U16_PowerSC_RegData;
extern uint16_t U16_EnergyAC_RegData;
extern uint16_t U16_EnergyBC_RegData;
extern uint16_t U16_CheckSUM_RegData;
extern uint16_t U16_CheckSUM_Data;

extern uint32_t U32_RMSIA_RegData;
extern uint32_t U32_RMSU_RegData;
extern uint32_t U32_POWERPA_RegData;
extern uint32_t U32_ENERGY_PA_RegData;

extern float F_AC_V;
extern float F_AC_I;
extern float F_AC_P;
extern float F_AC_E;
extern float F_AC_BACKUP_E;
extern float F_AC_PF;
extern float F_Angle;
extern float F_AC_LINE_Freq;

// 函数声明
void USART2_IRQHandler();
void Start_Send_UartData(uint8_t len);
void Clear_RxBuf();
uint8_t HLW8110_checkSum_Write(uint8_t u8_Reg_length);
uint8_t HLW8110_checkSum_Read(uint8_t u8_Reg_length);
void Uart_HLW8110_WriteREG_EN();
void Uart_HLW8110_WriteREG_DIS();
void Uart_HLW8110_Set_Channel_A();
void Uart_Read_HLW8110_Reg(uint8_t ADDR_Reg, uint8_t u8_reg_length);
void Uart_Write_HLW8110_Reg(uint8_t ADDR_Reg, uint8_t u8_reg_length, uint32_t u32_data);
void Uart_HLW8110_Reset();
uint8_t Judge_CheckSum_HLW8110_Calfactor();
void Init_HLW8110();
void Check_WriteReg_Success();
void Read_HLW8110_IA();
void Read_HLW8110_U();
void Read_HLW8110_PA();
void Read_HLW8110_EA();
void Read_HLW8110_LineFreq();
void Read_HLW8110_PF();
void Read_HLW8110_Angle();
void Calculate_HLW8110_MeterData();

#endif // HLW8110_H
```

### 示例主程序

```cpp
#include "HLW8110.h"

void setup() {
    Serial.begin(115200);
    Init_HLW8110();
    Serial.println("HLW8110 Initialized");
}

void loop() {
    // 调用库函数
    Read_HLW8110_IA();
    Read_HLW8110_U();
    Read_HLW8110_PA();
    Read_HLW8110_EA();
    Read_HLW8110_LineFreq();
    Read_HLW8110_Angle();
    Read_HLW8110_PF();
    
    Calculate_HLW8110_MeterData();
    
    delay(1000);
}
```

```c++
//
// Created by Lyu Troy on 2024/7/20.
//

#include "HLW8110.h"
#include <Setting.h>
#include <SoftwareSerial.h>
#include <cstdint>
/*
#define HIGH 1
#define LOW 0
*/
// 定义数据结构体，用于串口通讯时进行数据传送
union IntData
{
    uint16_t inte;
    uint8_t byte[2];
};

union LongData
{
    uint32_t word;
    uint16_t inte[2];
    uint8_t byte[4];
};

unsigned volatile char u8_TxBuf[10];  // 串口Tx发送端口寄存器
unsigned volatile char u8_RxBuf[10];  // 串口Rx接受端口寄存器
unsigned volatile char u8_TX_Length;  // 串口Tx发送端口寄存器长度
unsigned volatile char u8_RX_Length;  // 串口Rx发送端口寄存器长度
unsigned volatile char u8_RX_Index;   // 串口Rx接收端口寄存器索引，用于查找某一位的数据
// unsigned char    B_ReadReg_Time_EN;
// unsigned char    B_Tx_Finish;
volatile bool B_Rx_Finish;    // 接收数据完成标志位
volatile bool B_Rx_Data_ING;  // 接收数据标志位，<1:接收数据中，0：未接收到数据>
volatile bool B_Read_Error;   // UART读取数据校验和出错，<1:数据读错，0：数据读取正确>
// unsigned char    u8_ReadReg_Index;
// unsigned char    u8_ReadReg_Time; //  串口读取寄存器数据的时间

unsigned int U16_TempData;
unsigned int U16_IFData;
unsigned int U16_RIFData;
unsigned int U16_LineFData;
unsigned int U16_AngleData;
unsigned int U16_PFData;
unsigned int U16_HFConst_RegData;

unsigned short U16_RMSIAC_RegData;    // A通道电流转换系数
unsigned short U16_RMSIBC_RegData;    // B通道电流转换系数
unsigned short U16_RMSUC_RegData;     // 电压通道转换系数
unsigned short U16_PowerPAC_RegData;  // A通道功率转换系数
unsigned short U16_PowerPBC_RegData;  // B通道功率转换系数
unsigned short
    U16_PowerSC_RegData;  // 视在功率转换系数，如果选择A通道，则是A通道视在功率转换系数。A通道和B通道只能二者选择其一。
unsigned short U16_EnergyAC_RegData;  // A通道有功电能(量)转换系数
unsigned short U16_EnergyBC_RegData;  // A通道有功电能（量）转换系数
unsigned short U16_CheckSUM_RegData;  // 转换系数的CheckSum，校验位
unsigned short U16_CheckSUM_Data;     // 转换系数计算出来的CheckSum

unsigned int U16_Check_SysconReg_Data;
unsigned int U16_Check_EmuconReg_Data;
unsigned int U16_Check_Emucon2Reg_Data;

uint32_t U32_RMSIA_RegData;      // A通道电流有效值寄存器
uint32_t U32_RMSU_RegData;       // 电压有效值寄存器
uint32_t U32_POWERPA_RegData;    // A通道功率有效值寄存器
uint32_t U32_ENERGY_PA_RegData;  // A通道有功电能(量)有效值寄存器

unsigned long U32_RMSIB_RegData;      // B通道电流有效值寄存器
unsigned long U32_POWERPB_RegData;    // B通道功率有效值寄存器
unsigned long U32_ENERGY_PB_RegData;  // B通道有功电能(量)有效值寄存器

float F_AC_V;         // 电压有效值
float F_AC_I;         // A通道电流
float F_AC_P;         // A通道有功功率
float F_AC_E;         // A通道有功电能(量)
float F_AC_BACKUP_E;  // A通道电量备份
float F_AC_PF;        // 功率因素，A通道和B通道只能选其一
float F_Angle;        // 相角，A通道和B通道只能选其一

float F_AC_I_B;         // B通道电流有效值
float F_AC_P_B;         // B通道有功功率
float F_AC_E_B;         // B通道有功电能(量)
float F_AC_BACKUP_E_B;  // B通道电量备份
float F_AC_LINE_Freq;   // 市电线性频率

// 创建 SoftwareSerial 对象，使用GPIO13和GPIO16进行软串口通讯
SoftwareSerial mySerial(rxPin, txPin);

/*************************************************
 * @brief 初始化软串口
 *
 * @param void
 * @return void
 *************************************************/

void USART_Init()
{
    mySerial.begin(9600);  // HLW8110的波特率固定为这个频率
    mySerial.println("Software Serial Example");
}

/*************************************************
 * @brief 模拟 USART 中断处理函数，可以将函数放在中断中进行执行
 *
 * @param void
 * @return void
 *************************************************/
void USART2_IRQHandler()
{
    // 接收数据
    if (mySerial.available())
    {
        if (u8_RX_Index < u8_RX_Length)
        {
            u8_RxBuf[u8_RX_Index] = mySerial.read();  // 数据接收中
            u8_RX_Index++;
            B_Rx_Data_ING = true;  // 置数据接收标志位
        }
        else
        {
            B_Rx_Finish = true;  // 数据接收完毕
            u8_RX_Index = 0;
        }
    }
}

/*************************************************
 * @brief 通过软串口进行数据的发送
 *
 * @param void
 * @return void
 *************************************************/
void Start_Send_UartData(uint8_t len)
{
    for (uint8_t i = 0; i < len; i++)
    {
        mySerial.write(u8_TxBuf[i]);
        while (!mySerial.availableForWrite())
            ;  // 等待发送结束
    }
}

/*************************************************
 * @brief 清空接收缓存器的数据
 *
 * @param void
 * @return void
 *************************************************/
void Clear_RxBuf()
{
    for (uint8_t i = 0; i < RX_BUF_LENGTH; i++)
    {
        u8_RxBuf[i] = 0x00;
    }
    B_Rx_Data_ING = false;
    B_Rx_Finish = false;
    u8_RX_Index = 0;
}

/*************************************************
 * @brief 写寄存器的校验和计算
 *
 * @param uint8_t
 * @return uint8_t
 *************************************************/
uint8_t HLW8110_checkSum_Write(uint8_t u8_Reg_length)
{
    uint32_t a = 0x0000;
    for (uint8_t i = 0; i < (u8_Reg_length - 1); i++)
    {
        a += u8_TxBuf[i];
    }
    a = ~a;           // 将最后的结果进行按位取反
    return a & 0xff;  // 取最后的第八位数据
}

/*************************************************
 * @brief 读寄存器的校验和计算
 *
 * @param uint8_t
 * @return uint8_t
 *************************************************/
uint8_t HLW8110_checkSum_Read(uint8_t u8_Reg_length)
{
    uint32_t a = 0x0000;
    for (uint8_t i = 0; i < (u8_Reg_length - 1); i++)
    {
        a += u8_RxBuf[i];
    }
    a = a + u8_TxBuf[0] + u8_TxBuf[1];
    a = ~a;           // 将最后的结果进行按位取反
    return a & 0xff;  // 取最后的第八位数据
}

/*************************************************
 * @brief 启用寄存器写功能
 *
 * @param void
 * @return void
 *************************************************/
void Uart_HLW8110_WriteREG_EN()
{
    u8_TX_Length = 4;
    u8_RX_Length = 0;
    u8_TxBuf[0] = 0xa5;  // 发送第一帧的命令
    u8_TxBuf[1] = 0xea;  // 写使能命令
    u8_TxBuf[2] = 0xe5;  // 使能写操作
    u8_TxBuf[3] = HLW8110_checkSum_Write(u8_TX_Length);
    Start_Send_UartData(u8_TX_Length);
}

/*************************************************
 * @brief 禁用寄存器写功能
 *
 * @param void
 * @return void
 *************************************************/
void Uart_HLW8110_WriteREG_DIS()
{
    u8_TX_Length = 4;
    u8_RX_Length = 0;
    u8_TxBuf[0] = 0xa5;  // 发送第一帧的命令
    u8_TxBuf[1] = 0xea;  // 写保护命令
    u8_TxBuf[2] = 0xdc;  // 关闭写操作
    u8_TxBuf[3] = HLW8110_checkSum_Write(u8_TX_Length);
    Start_Send_UartData(u8_TX_Length);
}

/*************************************************
 * @brief 设置通道A
 *
 * 指定单签用于计算实在功率、功率因素、相角、瞬时视在功率和有
 * 功功率过载的信号知识为通道A，因此后续的代码只有通道A的函数
 * 没有通道B的函数。
 *
 * @param void
 * @return void
 *************************************************/
void Uart_HLW8110_Set_Channel_A()
{
    u8_TX_Length = 4;
    u8_RX_Length = 0;
    u8_TxBuf[0] = 0xa5;  // 发送第一帧命令
    u8_TxBuf[1] = 0xea;
    u8_TxBuf[2] = 0x5a;  // 电流通道A设置命令
    u8_TxBuf[3] = HLW8110_checkSum_Write(u8_TX_Length);
    Start_Send_UartData(u8_TX_Length);
}

/*************************************************
 * @brief 读寄存器
 *
 * 这里读取的寄存器是HLW8110的寄存器，
 *
 * @param ADDR_Reg, u8_reg_length
 * @return void
 *************************************************/
void Uart_Read_HLW8110_Reg(uint8_t ADDR_Reg, uint8_t u8_reg_length)
{
    u8_TxBuf[0] = 0xa5;
    u8_TxBuf[1] = ADDR_Reg;
    u8_TX_Length = 2;
    u8_RX_Length = u8_reg_length + 1;  // +1，因为接收的数据长度，除了REG值，还有一个校验和数据
    Clear_RxBuf();                     // 清空接收缓冲区
    Start_Send_UartData(u8_TX_Length);
}

/*************************************************
 * @brief 写寄存器
 *
 * 这里写的寄存器是HLW8110的寄存器。
 *
 * @param ADDR_Reg, u8_reg_length, u32_data
 * @return void
 *************************************************/
void Uart_Write_HLW8110_Reg(uint8_t ADDR_Reg, uint8_t u8_reg_length, uint32_t u32_data)
{
    union LongData
    {
        uint32_t word;
        uint8_t byte[4];
    } Temp_u32_a;

    u8_TxBuf[0] = 0xa5;
    u8_TxBuf[1] = ADDR_Reg | 0x80;
    Temp_u32_a.word = u32_data;

    for (uint8_t i = 0; i < u8_reg_length; i++)
    {
        u8_TxBuf[i + 2] = Temp_u32_a.byte[u8_reg_length - 1 - i];
    }

    u8_TX_Length = 3 + u8_reg_length;
    u8_RX_Length = 0;
    u8_TxBuf[u8_TX_Length - 1] = HLW8110_checkSum_Write(u8_TX_Length);
    Start_Send_UartData(u8_TX_Length);
}

/*************************************************
 * @brief HLW8110复位函数
 *
 * 通过串口对HLW8110进行复位
 *
 * @param void
 * @return void
 *************************************************/
void Uart_HLW8110_Reset()
{
    u8_TX_Length = 4;
    u8_RX_Length = 0;
    u8_TxBuf[0] = 0xa5;
    u8_TxBuf[1] = 0xea;  // 复位指令
    u8_TxBuf[2] = 0x96;  // 复位指令，接收到指令后芯片复位
    u8_TxBuf[3] = HLW8110_checkSum_Write(u8_TX_Length);
    Start_Send_UartData(u8_TX_Length);
}

/*************************************************
 * @brief 检查HLW8110数据校验和
 *
 * 检查HLW8110数据校验和
 *
 * @param void
 * @return void
 *************************************************/
uint8_t Judge_CheckSum_HLW8110_Calfactor()
{
    uint32_t a = 0xffff;
    // uint16_t b, c;
    uint8_t d;

    // 读取寄存器数据，REG_RMS_IAC_ADDR是校正后的A相电流有效值寄存器
    Uart_Read_HLW8110_Reg(REG_RMS_IAC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U16_RMSIAC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("A通道电流转换系数: " + String(U16_RMSIAC_RegData, HEX));
    }
    // 读取寄存器数据，REG_RMS_IBC_ADDR是矫正后的B相电流有效值寄存器
    Uart_Read_HLW8110_Reg(REG_RMS_IBC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U16_RMSIBC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("B通道电流转换系数: " + String(U16_RMSIBC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_RMS_UC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U16_RMSUC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("电压通道转换系数: " + String(U16_RMSUC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_POWER_PAC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U16_PowerPAC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("A通道功率转换系数: " + String(U16_PowerPAC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_POWER_PBC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U16_PowerPBC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("B通道功率转换系数: " + String(U16_PowerPBC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_POWER_SC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U16_PowerSC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("视在功率转换系数: " + String(U16_PowerSC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_ENERGY_AC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U16_EnergyAC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("A通道电量转换系数: " + String(U16_EnergyAC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_ENERGY_BC_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U16_EnergyBC_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("B通道电量转换系数: " + String(U16_EnergyBC_RegData, HEX));
    }

    Uart_Read_HLW8110_Reg(REG_CHECKSUM_ADDR, 2);
    delay(50);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U16_CheckSUM_RegData = (u8_RxBuf[0] << 8) + u8_RxBuf[1];
        Serial.println("系数校验和: " + String(U16_CheckSUM_RegData, HEX));
    }

    a = ~(0xffff + U16_RMSIAC_RegData + U16_RMSIBC_RegData + U16_RMSUC_RegData + U16_PowerPAC_RegData +
          U16_PowerPBC_RegData + U16_PowerSC_RegData + U16_EnergyAC_RegData + U16_EnergyBC_RegData);
    U16_CheckSUM_Data = a & 0xffff;

    Serial.println("计算系数校验和: " + String(U16_CheckSUM_Data, HEX));

    if (U16_CheckSUM_Data == U16_CheckSUM_RegData)
    {
        d = 1;
        Serial.println("校验和正确");
    }
    else
    {
        d = 0;
        Serial.println("校验和出错");
    }

    return d;
}

/*************************************************
 * @brief 初始化HLW8110
 *
 *
 * @param void
 * @return void
 *************************************************/
void Init_HLW8110()
{
    // 初始化 UART
    Serial.begin(9600);

    // // 设置 IO
    // pinMode(A0, OUTPUT);  // 示例 IO 引脚
    // pinMode(A1, OUTPUT);
    // digitalWrite(A0, LOW);
    // digitalWrite(A1, HIGH);

    Uart_HLW8110_WriteREG_EN();
    delay(10);

    Uart_HLW8110_Set_Channel_A();
    delay(10);

    Uart_Write_HLW8110_Reg(REG_SYSCON_ADDR, 2, 0x0a04);
    delay(10);

    Uart_Write_HLW8110_Reg(REG_EMUCON_ADDR, 2, 0x0001);
    Uart_Write_HLW8110_Reg(REG_EMUCON2_ADDR, 2, 0x0465);
    delay(10);

    Uart_HLW8110_WriteREG_DIS();
    Judge_CheckSum_HLW8110_Calfactor();
}

// 检验写入的 REG 是否正确写入
/*************************************************
 * @brief 检查写入的REG是否正确写入
 *
 *
 * @param void
 * @return void
 *************************************************/
void Check_WriteReg_Success()
{
    Uart_Read_HLW8110_Reg(REG_SYSCON_ADDR, 2);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U16_Check_SysconReg_Data = (u8_RxBuf[0] << 8) + (u8_RxBuf[1]);
        Serial.println("写入的SysconReg寄存器: " + String(U16_Check_SysconReg_Data, HEX));
    }
    else
    {
        Serial.println("SysconReg寄存器读取出错");
        B_Read_Error = 1;
    }

    Uart_Read_HLW8110_Reg(REG_EMUCON_ADDR, 2);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U16_Check_EmuconReg_Data = (u8_RxBuf[0] << 8) + (u8_RxBuf[1]);
        Serial.println("写入的EmuconReg寄存器: " + String(U16_Check_EmuconReg_Data, HEX));
    }
    else
    {
        Serial.println("EmuconReg寄存器读取出错");
        B_Read_Error = 1;
    }

    Uart_Read_HLW8110_Reg(REG_EMUCON2_ADDR, 2);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U16_Check_Emucon2Reg_Data = (u8_RxBuf[0] << 8) + (u8_RxBuf[1]);
        Serial.println("写入的Emucon2Reg寄存器: " + String(U16_Check_Emucon2Reg_Data, HEX));
    }
    else
    {
        Serial.println("Emucon2Reg寄存器读取出错");
        B_Read_Error = 1;
    }
}

/*************************************************
 * @brief 读取HLW8110的A通道的电流
 *
 * @param void
 * @return void
 *************************************************/
void Read_HLW8110_IA()
{
    float a;

    Uart_Read_HLW8110_Reg(REG_RMSIA_ADDR, 3);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U32_RMSIA_RegData = (uint32_t)(u8_RxBuf[0] << 16) + (uint32_t)(u8_RxBuf[1] << 8) + (uint32_t)(u8_RxBuf[2]);
        Serial.println("A通道电流寄存器: " + String(U32_RMSIA_RegData, HEX));
    }
    else
    {
        Serial.println("A通道电流寄存器读取出错");
        B_Read_Error = 1;
    }

    if ((U32_RMSIA_RegData & 0x800000) == 0x800000)
    {
        F_AC_I = 0;
    }
    else
    {
        a = (float)U32_RMSIA_RegData;
        a = a * U16_RMSIAC_RegData;
        a = a / 0x800000;         // 电流计算出来的浮点数单位是mA, 比如5003.12
        a = a / 1;                // 1 = 电流系数
        a = a / 1000;             // a = 5003mA, a / 1000 = 5.003A, 单位转换成A
        a = a * 1; /*D_CAL_A_I*/  // D_CAL_A_I是校正系数，默认是1
        F_AC_I = a;
    }
}

/*************************************************
 * @brief 读取HLW8110的A通道的电压
 *
 * @param void
 * @return void
 *************************************************/
void Read_HLW8110_U()
{
    float a;

    Uart_Read_HLW8110_Reg(REG_RMSU_ADDR, 3);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U32_RMSU_RegData = (uint32_t)(u8_RxBuf[0] << 16) + (uint32_t)(u8_RxBuf[1] << 8) + (uint32_t)(u8_RxBuf[2]);
        Serial.println("电压通道寄存器: " + String(U32_RMSU_RegData, HEX));
    }
    else
    {
        Serial.println("电压通道寄存器读取出错");
        B_Read_Error = 1;
    }

    if ((U32_RMSU_RegData & 0x800000) == 0x800000)
    {
        F_AC_V = 0;
    }
    else
    {
        a = (float)U32_RMSU_RegData;
        a = a * U16_RMSUC_RegData;
        a = a / 0x400000;
        a = a / 1;              // 1 = 电压系数
        a = a / 100;            // 计算出a = 22083.12mV, a / 100表示220.8312V，电压转换成V
        a = a * 1; /*D_CAL_U*/  // D_CAL_U是校正系数，默认是1
        F_AC_V = a;
    }
}

/*************************************************
 * @brief 读取HLW8110的A通道的功率
 *
 * @param void
 * @return void
 *************************************************/
void Read_HLW8110_PA()
{
    float a, b;

    Uart_Read_HLW8110_Reg(REG_POWER_PA_ADDR, 4);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U32_POWERPA_RegData = (uint32_t)(u8_RxBuf[0] << 24) + (uint32_t)(u8_RxBuf[1] << 16) +
                              (uint32_t)(u8_RxBuf[2] << 8) + (uint32_t)(u8_RxBuf[3]);
        Serial.println("A通道功率寄存器: " + String(U32_POWERPA_RegData, HEX));
    }
    else
    {
        Serial.println("A通道功率寄存器读取出错");
        B_Read_Error = 1;
    }

    if (U32_POWERPA_RegData > 0x80000000)
    {
        b = ~U32_POWERPA_RegData;
        a = (float)b;
    }
    else
    {
        a = (float)U32_POWERPA_RegData;
    }

    a = a * U16_PowerPAC_RegData;
    a = a / 0x80000000;
    a = a / 1;                // 1 = 电流系数
    a = a / 1;                // 1 = 电压系数
    a = a * 1; /*D_CAL_A_P*/  // D_CAL_A_P是校正系数，默认是1
    F_AC_P = a;               // 单位为W,比如算出来5000.123，表示5000.123W
}

/*************************************************
 * @brief 计算HLW8110电表数据
 *
 * @param void
 * @return void
 *************************************************/
void Calculate_HLW8110_MeterData()
{
    Check_WriteReg_Success();

    Read_HLW8110_IA();
    Read_HLW8110_U();
    Read_HLW8110_PA();
    Read_HLW8110_EA();

    Read_HLW8110_LineFreq();
    Read_HLW8110_Angle();
    Read_HLW8110_PF();

    Serial.println();
    Serial.println();
    Serial.println("交流测量,uart通讯方式");
    Serial.println("A通道电流转换系数: " + String(U16_RMSIAC_RegData, HEX));
    Serial.println("B通道电流转换系数: " + String(U16_RMSIBC_RegData, HEX));
    Serial.println("电压通道转换系数: " + String(U16_RMSUC_RegData, HEX));
    Serial.println("A通道功率转换系数: " + String(U16_PowerPAC_RegData, HEX));
    Serial.println("B通道功率转换系数: " + String(U16_PowerPBC_RegData, HEX));
    Serial.println("视在功率转换系数: " + String(U16_PowerSC_RegData, HEX));
    Serial.println("A通道电量转换系数: " + String(U16_EnergyAC_RegData, HEX));
    Serial.println("B通道电量转换系数: " + String(U16_EnergyBC_RegData, HEX));
    Serial.println("转换系数校验和: " + String(U16_CheckSUM_RegData, HEX));
    Serial.println("转换系数计算出的校验和: " + String(U16_CheckSUM_Data, HEX));

    Serial.println();
    Serial.println("A通道电流寄存器: " + String(U32_RMSIA_RegData, HEX));
    Serial.println("电压寄存器: " + String(U32_RMSU_RegData, HEX));
    Serial.println("A通道功率寄存器: " + String(U32_POWERPA_RegData, HEX));
    Serial.println("A通道电量寄存器: " + String(U32_ENERGY_PA_RegData, HEX));

    Serial.println();
    Serial.println("F_AC_I = " + String(F_AC_I) + " A");
    Serial.println("F_AC_V = " + String(F_AC_V) + " V");
    Serial.println("F_AC_P = " + String(F_AC_P) + " W");
    Serial.println("F_AC_BACKUP_E = " + String(F_AC_BACKUP_E) + " KWH");
    Serial.println("F_AC_LINE_Freq = " + String(F_AC_LINE_Freq) + " Hz");
    Serial.println("F_Angle = " + String(F_Angle));
    Serial.println("F_AC_PF = " + String(F_AC_PF));

    Serial.println();
    Serial.println();
    Serial.println("----------------------------------------------");
    Serial.println("----------------------------------------------");
}
```

在转换你的C代码为Arduino代码并解释归一化处理的过程中，首先需要了解每一步的具体作用。下面是对你的代码的转换和解释：

### 代码转换
以下是将你的C代码转换为Arduino格式的版本：

```cpp
#include <Arduino.h>

// 假设这些变量和函数在其他地方定义了
extern uint8_t u8_RxBuf[];
extern uint8_t u8_RX_Length;
extern uint16_t U16_EnergyAC_RegData;
extern uint32_t U32_ENERGY_PA_RegData;
extern uint16_t U16_HFConst_RegData;
extern float F_AC_E;
extern float F_AC_BACKUP_E;
extern float D_CAL_A_E;
extern uint8_t B_Read_Error;

uint8_t HLW8110_checkSum_Read(uint8_t length);
void Uart_Read_HLW8110_Reg(uint16_t reg, uint8_t length);
void delay(int ms);

/*************************************************
 * @brief 读取HLW8110的A通道的能量
 *
 * @param void
 * @return void
 *************************************************/
void Read_HLW8110_EA()
{
    float a;

    // 读取能量寄存器的数据
    Uart_Read_HLW8110_Reg(REG_ENERGY_PA_ADDR, 3); 
    delay(10);
    
    // 校验数据的正确性
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        // 将字节数组转换为24位无符号整数
        U32_ENERGY_PA_RegData = (uint32_t)(u8_RxBuf[0] << 16) + (uint32_t)(u8_RxBuf[1] << 8) + (uint32_t)(u8_RxBuf[2]);
        Serial.println("A通道有功电能寄存器: " + String(U32_ENERGY_PA_RegData, HEX));
    }
    else
    {
        Serial.println("A通道有功电能寄存器读取出错");
        B_Read_Error = 1;
        return; // 如果校验失败，直接返回
    }
    
    // 读取HFCONST寄存器的数据
    Uart_Read_HLW8110_Reg(REG_HFCONST_ADDR, 2); 
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        // 将字节数组转换为16位无符号整数
        U16_HFConst_RegData = (uint16_t)(u8_RxBuf[0] << 8) + (uint16_t)(u8_RxBuf[1]);
        Serial.println("HFCONST常数 = " + String(U16_HFConst_RegData));
    }
    else
    {
        Serial.println("HFCONST常数寄存器读取出错");
        B_Read_Error = 1;
        return; // 如果校验失败，直接返回
    }

    // 电能计算，电能 = (U32_ENERGY_PA_RegData * U16_EnergyAC_RegData * HFCONST) / (K1*K2 * 2^29 * 4096)
    // HFCONST: 默认值是0x1000, HFCONST / (2^29 * 4096) = 0x20000000
    a =  (float)U32_ENERGY_PA_RegData;	
    a = a * U16_EnergyAC_RegData;
    a = a / 0x20000000;  // 电能单位是0.001KWH，例如算出来是2.002，表示2.002KWH    
    a = a / 1;  // 1 = 电流系数
    a = a / 1;  // 1 = 电压系数
    a = a * D_CAL_A_E;  // D_CAL_A_E是校正系数，默认是1
    F_AC_E = a;
    F_AC_BACKUP_E = F_AC_E;
}
```

### 归一化处理除以 `0x20000000` 的原因

1. **读取能量寄存器和HFCONST寄存器**：
   - 读取能量寄存器的数据，并校验正确性。
   - 读取HFCONST寄存器的数据，并校验正确性。

2. **归一化处理**：
   - 能量数据是通过以下公式计算的：
     ![image-20240731185159129](C:\Users\LyuTroy\AppData\Roaming\Typora\typora-user-images\image-20240731185159129.png)
   - HFCONST默认值是`0x1000`，当进行公式计算时，HFCONST/(2^29 \times 4096) 的结果是 `0x20000000`。
   - 归一化除以 `0x20000000` 是因为在公式中，这个值用于将计算结果转换为合适的单位。电能单位是0.001KWH，通过这样的归一化处理，可以得到精确的能量值。
   
3. **电流和电压系数**：
   - 除以1是为了保留电流和电压系数的原始值。如果有不同的校正系数，可以在此进行调整。

4. **校正系数**：
   - `D_CAL_A_E` 是校正系数，用于进一步校正测量值，确保最终结果的准确性。默认值是1，可以根据实际情况进行调整。

通过这些步骤，你可以准确地将读取的寄存器数据转换为实际的能量值。每一步的归一化处理和校正系数应用都是为了确保测量结果的精确性。

根据我们刚刚计算的K1和K2值，你的代码中用于归一化处理的系数确实需要进行调整。这里是调整后的代码和相应的解释：

### 调整后的代码

```cpp
#include <Arduino.h>

// 假设这些变量和函数在其他地方定义了
extern uint8_t u8_RxBuf[];
extern uint8_t u8_RX_Length;
extern uint16_t U16_EnergyAC_RegData;
extern uint32_t U32_ENERGY_PA_RegData;
extern uint16_t U16_HFConst_RegData;
extern float F_AC_E;
extern float F_AC_BACKUP_E;
extern float D_CAL_A_E;
extern uint8_t B_Read_Error;

uint8_t HLW8110_checkSum_Read(uint8_t length);
void Uart_Read_HLW8110_Reg(uint16_t reg, uint8_t length);
void delay(int ms);

/*************************************************
 * @brief 读取HLW8110的A通道的能量
 *
 * @param void
 * @return void
 *************************************************/
void Read_HLW8110_EA()
{
    float a;

    // 读取能量寄存器的数据
    Uart_Read_HLW8110_Reg(REG_ENERGY_PA_ADDR, 3); 
    delay(10);
    
    // 校验数据的正确性
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        // 将字节数组转换为24位无符号整数
        U32_ENERGY_PA_RegData = (uint32_t)(u8_RxBuf[0] << 16) + (uint32_t)(u8_RxBuf[1] << 8) + (uint32_t)(u8_RxBuf[2]);
        Serial.println("A通道有功电能寄存器: " + String(U32_ENERGY_PA_RegData, HEX));
    }
    else
    {
        Serial.println("A通道有功电能寄存器读取出错");
        B_Read_Error = 1;
        return; // 如果校验失败，直接返回
    }
    
    // 读取HFCONST寄存器的数据
    Uart_Read_HLW8110_Reg(REG_HFCONST_ADDR, 2); 
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        // 将字节数组转换为16位无符号整数
        U16_HFConst_RegData = (uint16_t)(u8_RxBuf[0] << 8) + (uint16_t)(u8_RxBuf[1]);
        Serial.println("HFCONST常数 = " + String(U16_HFConst_RegData));
    }
    else
    {
        Serial.println("HFCONST常数寄存器读取出错");
        B_Read_Error = 1;
        return; // 如果校验失败，直接返回
    }

    // 电能计算，电能 = (U32_ENERGY_PA_RegData * U16_EnergyAC_RegData * HFCONST) / (K1 * K2 * 2^29 * 4096)
    // HFCONST: 默认值是0x1000, HFCONST / (2^29 * 4096) = 0x20000000
    // K1 = 1, K2 = 1400
    a = (float)U32_ENERGY_PA_RegData;
    a = a * U16_EnergyAC_RegData;
    a = a * U16_HFConst_RegData;
    a = a / (1 * 1400 * 0x20000000);  // 归一化因子修改为：K1 = 1, K2 = 1400
    a = a / 1;  // 电流系数，默认为1
    a = a / 1;  // 电压系数，默认为1
    a = a * D_CAL_A_E;  // 校正系数，默认值为1
    F_AC_E = a;
    F_AC_BACKUP_E = F_AC_E;
}
```

### 解释
1. **电流通道**：
   
   - K1 = 1：根据电流通道的实际电阻和采样电阻的计算。
   
2. **电压通道**：
   - K2 = 1400：根据电压通道的电阻分压比的计算。

3. **归一化因子调整**：
   - 将原来的归一化因子调整为：K1 = 1 和 K2 = 1400。
   - 归一化计算：
     \$$
     a = a / (1 \times 1400 \times 0x20000000)
     $$
   - $$
   \begin{align*}
   y = y(x,t) &= A e^{i\theta} \\
   &= A (\cos \theta + i \sin \theta) \\
   &= A (\cos(kx - \omega t) + i \sin(kx - \omega t)) \\
   &= A\cos(kx - \omega t) + i A\sin(kx - \omega t)  \\
   &= A\cos \Big(\frac{2\pi}{\lambda}x - \frac{2\pi v}{\lambda} t \Big) + i A\sin \Big(\frac{2\pi}{\lambda}x - \frac{2\pi v}{\lambda} t \Big)  \\
   &= A\cos \frac{2\pi}{\lambda} (x - v t) + i A\sin \frac{2\pi}{\lambda} (x - v t)
   \end{align*}
   $$

### 总结
这样调整后的代码应该可以准确反映电路中实际使用的电阻值和分压比，从而确保能量计算的准确性。请根据实际情况进行测试和验证，确保计算结果符合预期。

根据张军的电路原理图计算完成的新代码

根据新的K1和K2参数（K1=1，K2=1400），以下是你提供的所有函数的更新版本：

### 电流读取函数
```cpp
/*************************************************
 * @brief 读取HLW8110的A通道的电流
 *
 * @param void
 * @return void
 *************************************************/
void Read_HLW8110_IA()
{
    float a;

    Uart_Read_HLW8110_Reg(REG_RMSIA_ADDR, 3);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U32_RMSIA_RegData = (uint32_t)(u8_RxBuf[0] << 16) + (uint32_t)(u8_RxBuf[1] << 8) + (uint32_t)(u8_RxBuf[2]);
        Serial.println("A通道电流寄存器: " + String(U32_RMSIA_RegData, HEX));
    }
    else
    {
        Serial.println("A通道电流寄存器读取出错");
        B_Read_Error = 1;
        return;
    }

    if ((U32_RMSIA_RegData & 0x800000) == 0x800000)  // 检测最大值
    {
        F_AC_I = 0;
    }
    else
    {
        a = (float)U32_RMSIA_RegData;
        a = a * U16_RMSIAC_RegData;
        a = a / 0x800000;         // 电流计算出来的浮点数单位是mA, 比如5003.12，进行归一化操作
        a = a / 1;                // 电流系数，默认为1
        a = a / 1000;             // 将mA转换为A
        a = a * 1; /*D_CAL_A_I*/  // D_CAL_A_I是校正系数，默认是1
        F_AC_I = a;
    }
}
```

### 电压读取函数
```cpp
/*************************************************
 * @brief 读取HLW8110的A通道的电压
 *
 * @param void
 * @return void
 *************************************************/
void Read_HLW8110_U()
{
    float a;

    Uart_Read_HLW8110_Reg(REG_RMSU_ADDR, 3);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U32_RMSU_RegData = (uint32_t)(u8_RxBuf[0] << 16) + (uint32_t)(u8_RxBuf[1] << 8) + (uint32_t)(u8_RxBuf[2]);
        Serial.println("电压通道寄存器: " + String(U32_RMSU_RegData, HEX));
    }
    else
    {
        Serial.println("电压通道寄存器读取出错");
        B_Read_Error = 1;
        return;
    }

    if ((U32_RMSU_RegData & 0x800000) == 0x800000)
    {
        F_AC_V = 0;
    }
    else
    {
        a = (float)U32_RMSU_RegData;
        a = a * U16_RMSUC_RegData;
        a = a / 0x800000;         // 电压计算出来的浮点数单位是mV
        a = a / 1400;             // 电压系数，K2 = 1400
        a = a / 1000;             // 将mV转换为V
        a = a * 1; /*D_CAL_U*/    // D_CAL_U是校正系数，默认是1
        F_AC_V = a;
    }
}
```

### 功率读取函数
```cpp
/*************************************************
 * @brief 读取HLW8110的A通道的功率
 *
 * @param void
 * @return void
 *************************************************/
void Read_HLW8110_PA()
{
    float a, b;

    Uart_Read_HLW8110_Reg(REG_POWER_PA_ADDR, 4);
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        U32_POWERPA_RegData = (uint32_t)(u8_RxBuf[0] << 24) + (uint32_t)(u8_RxBuf[1] << 16) +
                              (uint32_t)(u8_RxBuf[2] << 8) + (uint32_t)(u8_RxBuf[3]);
        Serial.println("A通道功率寄存器: " + String(U32_POWERPA_RegData, HEX));
    }
    else
    {
        Serial.println("A通道功率寄存器读取出错");
        B_Read_Error = 1;
        return;
    }

    if (U32_POWERPA_RegData > 0x80000000)
    {
        b = ~U32_POWERPA_RegData;
        a = (float)b;
    }
    else
    {
        a = (float)U32_POWERPA_RegData;
    }

    a = a * U16_PowerPAC_RegData;
    a = a / 0x80000000;          // 归一化
    a = a / 1;                   // 电流系数，默认为1
    a = a / 1;                   // 电压系数，默认为1
    a = a * 1; /*D_CAL_A_P*/     // D_CAL_A_P是校正系数，默认是1
    F_AC_P = a;                  // 单位为W
}
```

### 能量读取函数
```cpp
/*************************************************
 * @brief 读取HLW8110的A通道的能量
 *
 * @param void
 * @return void
 *************************************************/
void Read_HLW8110_EA()
{
    float a;

    // 读取能量寄存器的数据
    Uart_Read_HLW8110_Reg(REG_ENERGY_PA_ADDR, 3); 
    delay(10);
    
    // 校验数据的正确性
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        // 将字节数组转换为24位无符号整数
        U32_ENERGY_PA_RegData = (uint32_t)(u8_RxBuf[0] << 16) + (uint32_t)(u8_RxBuf[1] << 8) + (uint32_t)(u8_RxBuf[2]);
        Serial.println("A通道有功电能寄存器: " + String(U32_ENERGY_PA_RegData, HEX));
    }
    else
    {
        Serial.println("A通道有功电能寄存器读取出错");
        B_Read_Error = 1;
        return; // 如果校验失败，直接返回
    }
    
    // 读取HFCONST寄存器的数据
    Uart_Read_HLW8110_Reg(REG_HFCONST_ADDR, 2); 
    delay(10);
    if (u8_RxBuf[u8_RX_Length - 1] == HLW8110_checkSum_Read(u8_RX_Length))
    {
        // 将字节数组转换为16位无符号整数
        U16_HFConst_RegData = (uint16_t)(u8_RxBuf[0] << 8) + (uint16_t)(u8_RxBuf[1]);
        Serial.println("HFCONST常数 = " + String(U16_HFConst_RegData));
    }
    else
    {
        Serial.println("HFCONST常数寄存器读取出错");
        B_Read_Error = 1;
        return; // 如果校验失败，直接返回
    }

    // 电能计算，电能 = (U32_ENERGY_PA_RegData * U16_EnergyAC_RegData * HFCONST) / (K1 * K2 * 2^29 * 4096)
    // HFCONST: 默认值是0x1000, HFCONST / (2^29 * 4096) = 0x20000000
    // K1 = 1, K2 = 1400
    a = (float)U32_ENERGY_PA_RegData;
    a = a * U16_EnergyAC_RegData;
    a = a * U16_HFConst_RegData;
    a = a / (1 * 1400 * 0x20000000);  // 归一化因子修改为：K1 = 1, K2 = 1400
    a = a / 1;  // 电流系数，默认为1
    a = a / 1;  // 电压系数，默认为1
    a = a * 1;  // 校正系数，默认值为1
    F_AC_E = a;
    F_AC_BACKUP_E = F_AC_E;
}
```

### 解释
1. **电流通道**：
   - `K1 = 1` 是电流通道的校正系数。
   - 归一化处理没有变化，因为K

1 = 1。

2. **电压通道**：
   - `K2 = 1400` 是电压通道的校正系数。
   - 在电压计算中应用K2的归一化处理。

3. **功率通道**：
   - 功率计算中的归一化处理没有变化。

4. **能量通道**：
   - 使用新的K1和K2值来进行归一化处理。

确保这些调整后的代码能在你的硬件和具体应用中得到正确的结果。如果需要进一步调整，建议在实际测量中验证这些系数的准确性。



抱歉，理解错误。让我们更新代码，使其只转换每行中的第一个十六进制码，而忽略第二个码。下面是修正后的 Python 脚本：

```python
import tkinter as tk
from tkinter import messagebox

def convert_to_unsigned_char(data):
    lines = data.strip().split('\n')
    bytes_list = []
    characters = []
    for line in lines:
        parts = line.split()
        if len(parts) != 3:
            continue  # 跳过没有恰好3个部分的行
        character, code1, _ = parts  # 只使用第一个码
        characters.append(character)
        bytes_list += [f"0x{code1[i:i+2]}" for i in range(0, len(code1), 2)]
    all_characters = ''.join(characters)
    unsigned_char_declaration = f"unsigned char show[] = {{{', '.join(bytes_list)}}};  // {all_characters}"
    return unsigned_char_declaration

def on_convert():
    input_data = text_input.get("1.0", tk.END)
    result = convert_to_unsigned_char(input_data)
    result_output.delete("1.0", tk.END)
    result_output.insert(tk.END, result)

# 设置主应用窗口
root = tk.Tk()
root.title("十六进制转换器")

# 文本输入框
text_input = tk.Text(root, height=10, width=50)
text_input.pack(pady=10)

# 转换按钮
convert_button = tk.Button(root, text="转换", command=on_convert)
convert_button.pack(pady=5)

# 文本输出框
result_output = tk.Text(root, height=10, width=50)
result_output.pack(pady=10)

# 启动应用
root.mainloop()
```

### 代码说明：

1. **提取第一个码**：在处理输入的每一行时，只使用第一个十六进制码 `code1`。

2. **字符拼接**：将所有字符拼接成一个字符串以注释说明，便于理解每个字节对应的字符。

3. **生成单个变量声明**：生成一个 `unsigned char` 数组来表示所有字符的第一个十六进制码。

### 使用方法：

- **运行脚本**：启动 GUI 界面。
- **输入数据**：在文本输入框中输入格式为“字符 十六进制码1 十六进制码2”的数据。
- **点击“转换”**：点击按钮处理数据。
- **查看输出**：输出框中将显示格式化后的 C 语言数组声明。

这样，脚本会忽略第二个码，只使用第一个码来生成输出。希望这个版本符合你的需求！





IoU（Intersection over Union，交并比）是计算机视觉领域中评估模型预测结果与真实标签之间重叠程度的重要指标，特别是在目标检测和图像分割任务中广泛使用。IoU 阈值（IoU threshold）是决定模型预测结果是否被认为是正确检测的关键参数。

### 什么是 IoU?

**IoU** 是两个区域之间的重叠度量，通常用于比较模型预测的边界框与实际的真实边界框（Ground Truth）之间的相似性。它的计算方式如下：

\[
\text{IoU} = \frac{\text{预测边界框与真实边界框的交集面积}}{\text{预测边界框与真实边界框的并集面积}}
\]

- **交集（Intersection）**: 是预测框和真实框重叠的部分。
- **并集（Union）**: 是预测框和真实框合并后的区域。

IoU 的值范围在 0 到 1 之间，其中：
- **0** 表示两个框完全不重叠。
- **1** 表示两个框完全重合。

### IoU 阈值的意义

**IoU 阈值** 是一个预定义的数值，用于判断预测结果是否足够好被视为一次“正确”的检测。在目标检测任务中，模型通常会输出一系列预测边界框，每个框都有一个与之对应的置信度分数。为了确定哪些预测是准确的，模型会将预测框的 IoU 与真实框的 IoU 进行比较。

- 如果 IoU 值高于这个阈值，则认为这个预测是“正确”的，称为 True Positive（真正例）。
- 如果 IoU 值低于这个阈值，则认为这个预测是不准确的，称为 False Positive（假正例）。

### 常用的 IoU 阈值

- **0.5（50%）**: 这是最常用的阈值，表示预测框和真实框有 50% 以上的重叠即被视为正确检测。这是一个宽松的标准，可能会容忍一些较差的检测结果。
  
- **0.75（75%）** 或 **更高**: 使用较高的 IoU 阈值（例如 0.75 或 0.9）可以确保模型预测的边界框与真实边界框非常接近，因此标准更加严格。

### 应用中的选择

- **任务需求**: 不同的任务对 IoU 阈值的要求不同。例如，在自动驾驶中，检测精度非常关键，因此通常会使用更高的 IoU 阈值。在某些宽松的应用中，可能只需 0.5 的 IoU 阈值。
  
- **评估指标**: 在评估模型性能时，通常会在不同的 IoU 阈值下计算 mAP（平均精度）值，以衡量模型在各种严格条件下的表现。

### 总结

IoU 阈值是目标检测任务中评估预测结果准确性的重要标准。选择合适的 IoU 阈值可以根据具体应用的需求决定，一般来说，阈值越高，要求的预测框与真实框的重合度越高，模型的检测结果会更加严格。



这张表格列出了YOLOv5模型的一些重要性能指标和参数，通常用于比较不同版本的YOLOv5模型（例如 YOLOv5s、YOLOv5m、YOLOv5l 等）。下面是各个列的含义解释：

### 1. `size (pixels)`
- **含义**: 输入图像的尺寸，通常是正方形的宽度或高度（例如 640 表示 640x640 的输入图像）。
- **影响**: 输入图像的大小会影响模型的推理速度和精度。较大的输入图像可能会捕捉更多的细节，从而提高精度，但同时也会增加计算量和推理时间。

### 2. `mAPval 50-95`
- **含义**: 这个指标表示在 COCO 数据集上计算出的模型的平均精度（mean Average Precision，mAP），在不同的 IoU 阈值（从 0.5 到 0.95，每隔 0.05）下的平均值。
- **影响**: 这个值通常用来衡量模型的总体检测性能，值越高表示模型的检测能力越强。这个 mAP 指标更严格，因为它考虑了不同 IoU 阈值的平均值。

### 3. `mAPval 50`
- **含义**: 这个指标表示在 IoU 阈值为 0.5 时的平均精度（mAP）。IoU（Intersection over Union）是衡量预测边界框与真实边界框重叠程度的指标。
- **影响**: 这个指标反映了模型在宽松条件下的检测性能，值越高越好。

### 4. `Speed CPU b1 (ms)`
- **含义**: 使用单张图像（batch size 为 1）在 CPU 上进行推理时的平均时间，单位是毫秒（ms）。
- **影响**: 这个数值越小，表示模型在 CPU 上的推理速度越快，适合在没有 GPU 的设备上进行部署。

### 5. `Speed V100 b1 (ms)`
- **含义**: 使用单张图像（batch size 为 1）在 NVIDIA V100 GPU 上进行推理时的平均时间，单位是毫秒（ms）。
- **影响**: 这个值表示在高性能 GPU 上的推理速度，数值越小表示模型在 GPU 上的推理速度越快。

### 6. `Speed V100 b32 (ms)`
- **含义**: 使用 32 张图像（batch size 为 32）在 NVIDIA V100 GPU 上进行推理时的平均时间，单位是毫秒（ms）。
- **影响**: 这个指标反映了模型在高性能 GPU 上批量处理时的推理速度，数值越小表示批量推理效率越高。

### 7. `params (M)`
- **含义**: 模型的参数数量，单位是百万（M，表示百万个参数）。
- **影响**: 参数数量越多，模型通常越复杂，可能在精度上有所提升，但也会导致更大的计算和存储需求。

### 8. `FLOPs @640 (B)`
- **含义**: 模型在输入图像尺寸为 640x640 时的浮点运算次数（FLOPs），单位是十亿次（B 表示十亿次操作）。
- **影响**: FLOPs 是衡量模型计算量的指标，数值越大表示模型计算量越高。通常，计算量与模型复杂度和推理时间成正比。

### 总结

- **精度指标 (`mAP`)**: 用于评估模型的检测性能，越高越好。
- **速度 (`Speed`)**: 评估模型在不同硬件和批处理大小下的推理速度，越低越好。
- **参数量 (`params`) 和计算量 (`FLOPs`)**: 用于衡量模型的复杂度和计算需求，适合根据资源限制选择合适的模型版本。

这些指标可以帮助你根据具体的需求选择合适的 YOLOv5 模型版本，比如在高精度要求下选择较大的模型（如 YOLOv5l 或 YOLOv5x），在资源受限或实时性要求高的场景下选择较小的模型（如 YOLOv5s）。



在你使用YOLO神经网络进行目标检测时，出现了食槽被错误识别为猪的情况，这是一个常见的问题，通常由以下几个因素引起：

### 1. **训练数据不足或标签不准确**：
   - 如果你的训练数据中包含了类似食槽的位置，但它们被错误标记为猪，模型可能会学习到错误的特征，从而将食槽误识别为猪。
   - 解决方案：检查和清理你的训练数据，确保所有的物体都被正确标记。你可以通过增加训练数据的多样性，并确保每个标签的准确性来减少这种错误。

### 2. **物体相似性导致的误识别**：
   - 食槽和猪可能在形状或颜色上有一些相似之处，特别是在摄像头视角或光照条件下。这可能会导致模型混淆这两者。
   - 解决方案：你可以通过数据增强（如旋转、翻转、缩放等），让模型更好地学习食槽与猪的不同特征。同时，考虑引入食槽的标签，并明确地训练模型区分它们。

### 3. **模型复杂度或训练不足**：
   - 如果模型的复杂度不够高，或者训练次数不够多，它可能无法正确区分细微的差别。
   - 解决方案：增加训练的epoch数量或使用更复杂的模型结构。此外，确保模型的训练过程没有出现过拟合或欠拟合的情况。

### 4. **区域标注问题**：
   - 如果你的训练集中，食槽的区域没有被标注为空，模型可能会将其视为猪的一部分。
   - 解决方案：明确在训练集中的每个图像标注食槽，并将其作为一种不需要识别的类进行训练。

### 5. **后处理步骤调整**：
   - YOLO在检测之后有一个NMS（非极大值抑制）步骤来减少冗余的检测结果。如果你的置信度阈值设置过低，可能会导致食槽被误检测为猪。
   - 解决方案：尝试调整NMS的阈值或置信度阈值，以减少误检。

通过上述方法的组合，你可以减少或消除食槽被误识别为猪的现象。如果问题仍然存在，建议查看误识别的样本，分析其特征，并进一步调整模型的训练策略。



### 上采样（Upsampling）和下采样（Downsampling）

**上采样**和**下采样**是图像处理和深度学习中常见的操作，主要用于改变图像的空间分辨率。

- **下采样（Downsampling）**：指的是将输入图像的空间分辨率降低，也就是减少图像的宽度和高度。例如，原本大小为640×640的图像，经过下采样后可能变为320×320。这通常通过池化操作（如最大池化或平均池化）、卷积操作（带步幅的卷积）等来实现。下采样的目的是减少数据的尺寸，提取更高层次的特征，并减少计算量。

- **上采样（Upsampling）**：与下采样相反，上采样是将图像的分辨率增大，增加图像的宽度和高度。例如，将图像从320×320放大到640×640。这可以通过转置卷积、插值（如双线性插值）等方式实现。上采样常用于生成模型或卷积神经网络中的反卷积操作，以恢复图像细节。

### YOLOv5的第一层卷积操作解读

在YOLOv5的第一层卷积操作中，你提到的输入是`1*3*640*640`，经过卷积操作后变为`1*32*320*320`。让我们逐步解释这是什么过程：

- **输入形状`1*3*640*640`**：
  - `1` 表示批次大小，即只有一张图像输入。
  - `3` 表示图像的通道数，也就是RGB通道，分别是红、绿、蓝三通道。
  - `640*640` 表示图像的空间分辨率，也就是图像的宽度和高度都是640像素。

- **卷积操作**：
  卷积层的核心参数是卷积核（滤波器），卷积核的作用是提取图像的特征。卷积操作会应用多个卷积核来对图像进行处理。

  - 在YOLOv5的第一层，通常使用一个大小为`3×3`的卷积核（卷积核通常应用于RGB三个通道），并且有`32`个不同的卷积核。这意味着每个卷积核都会处理图像的三个通道，并生成一个新的特征图（feature map）。
  
  - 输出的形状是`1*32*320*320`，其中：
    - `32`表示输出通道的数量（卷积核的数量），也就是生成了32个特征图。
    - `320*320`是输出的空间分辨率，经过卷积操作后图像的宽度和高度都变成了320。
    - 这通常伴随着步幅（stride）的应用，第一层卷积通常采用步幅为2（`stride=2`），这意味着输入图像尺寸减半（从`640×640`降为`320×320`）。

### **RGB通道的处理：**

在卷积操作中，RGB通道并不会“消失”，而是作为输入的一部分被整合进来。具体来说，卷积操作会在每一个通道上应用相应的卷积核权重，然后将它们的结果相加，形成一个新的特征图。对于每一个卷积核，它会处理图像的三个通道，卷积核的权重会分别应用到R、G、B通道上，最终生成一个二维的特征图。因此，经过32个卷积核的处理，最终生成了32个新的特征图。

通道数的变化实际上是卷积核个数的增加，而不是丢失了原来的通道信息。换句话说，RGB通道的信息被压缩并编码为32个新通道的特征图，这些特征图表示了图像的不同特征和模式。

### **总结**：
- **上采样**：增加图像的分辨率。
- **下采样**：降低图像的分辨率。
- 在YOLOv5中，输入图像通过第一层卷积时，RGB通道的三通道信息被多个卷积核（32个）提取并融合，生成了32个新的特征图。这是为什么形状变为`1*32*320*320`，其中图像的空间维度减半，通道数变为32。

这个日志信息来自TensorFlow，解释了当前启用了**oneDNN**（以前称为MKL-DNN）的自定义操作。oneDNN是一个优化的库，专门用于加速深度学习模型的计算，特别是在Intel CPU上。启用oneDNN后，某些操作可能会使用不同的优化算法，从而导致浮点计算的舍入误差，这可能会导致与未启用oneDNN时的数值结果略有不同。

日志信息的关键点和含义如下：

1. **oneDNN自定义操作已启用**：
   TensorFlow目前使用oneDNN优化，这可能会加速模型训练和推理，尤其是在CPU上运行时。

2. **可能的浮点数舍入误差**：
   由于oneDNN的优化，一些计算的顺序可能会有所不同，这可能导致微小的数值误差。这个误差通常不会对模型结果产生重大影响，但如果你在调试或对结果的数值精度要求极高时，可能需要考虑这一点。

3. **如何禁用oneDNN优化**：
   如果你希望禁用这些优化，可以设置环境变量 `TF_ENABLE_ONEDNN_OPTS=0` 来关闭oneDNN操作。你可以在运行Python代码之前通过以下方式禁用它：
   
   - 在Linux/macOS上：
     ```bash
     export TF_ENABLE_ONEDNN_OPTS=0
     ```

   - 在Windows上（命令行）：
     ```bash
     set TF_ENABLE_ONEDNN_OPTS=0
     ```

禁用oneDNN可能会使计算结果在数值上更加一致，但可能会导致性能下降，尤其是在使用CPU时。

### 什么时候需要禁用oneDNN？
- 如果你对数值精度有非常严格的要求，并且不希望因为浮点舍入误差导致结果有任何变化。
- 如果你在调试模型的计算结果，想要避免不同计算路径导致的误差。

通常情况下，启用oneDNN的性能提升是值得的，数值误差的影响通常也非常小。





